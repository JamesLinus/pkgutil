#!/usr/bin/env perl -w

# bldcat - build a CSW catalog from packages in a directory
# Copyright (C) 2008-2009 Peter Bonivart

# $Id$

use strict;
use Getopt::Long;
Getopt::Long::Configure qw(no_ignore_case bundling);

eval { require Digest::MD5; };
die "\nMD5 support not available! Install CSWperl and use that\nfor pkgutil. Do that by having /opt/csw/bin before\n/usr/bin in your path.\n" if ($@);

my $tmpdir = "/tmp/bldcat.$$.$^T";
my $pkgdir = ".";
my ($deptmp,$status,$pkgname,$ideptmp);
my ($description,$common,$version,$package,$pkgfile,$hash,$size,
    $deps,$category,$help,$ideps);
my %oldcatalog;
my %olddescriptions;
my $format = 9;

GetOptions("h|help"	=> \$help,
           "f|format=s"	=> \$format) || usage();

usage() if $help;
if (scalar(@ARGV) > 0) {
  $pkgdir = $ARGV[0];
} else {
  usage();
}

if ($format != 8) {
  $format = 9;
}

sub usage {
  print "bldcat, build CSW catalogs.\n\n";
  print "Usage: bldcat [-fh] <package dir>\n";
  print "\n  -f, --format=x\tSet catalog format (8|[9])";
  print "\n  -h, --help\t\tShow this help\n";
  print "\nWritten and maintained by Peter Bonivart.\n";
  exit 1;
}

if (open (CATALOG,"$pkgdir/catalog")) {
  while (<CATALOG>) {
    chomp;
    my @line = split /\s+/;
    my $hash = $line[4];
    $oldcatalog{$hash} = \@line;
  }
  close CATALOG;
}

if (open (DESCRIPTIONS,"$pkgdir/descriptions")) {
  while (<DESCRIPTIONS>) {
    chomp;
    my @line = split /\s+/;
    my $common = $line[0];
    $olddescriptions{$common} = $_;
  }
  close DESCRIPTIONS;
}

open (CATALOG,">$pkgdir/catalog.new") || die "Could not write new catalog at $pkgdir/catalog.new: $!";
open (DESCRIPTIONS,">$pkgdir/descriptions.new") || die "Could not write new descriptions at $pkgdir/descriptions.new: $!";

foreach my $file (glob "$pkgdir/*") {
  ($common,$version,$package,$pkgfile,$hash,$size,$deps,$category,$ideps) = ("","","","","","","","","");
  next unless (-r $file);		# must be a readable file
  next unless ($file =~ /\.pkg(\.gz)?$/);	# must end with .pkg or .pkg.gz

  # Calculate hash before we do anything else to look up the cache
  if (! $hash) {
    open (FILE2,"<$file") || die "Could not open $file: $!\n";
    binmode (FILE2);
    $hash = Digest::MD5->new->addfile(*FILE2)->hexdigest;
    close FILE2;
  }

  if (exists $oldcatalog{$hash} && exists $olddescriptions{$oldcatalog{$hash}[0]}) {
    print "Reusing old information for $file\n";
    print CATALOG join(' ', @{$oldcatalog{$hash}}), "\n";
    print DESCRIPTIONS $olddescriptions{$oldcatalog{$hash}[0]}, "\n";
    next;
  }

  print "Inspecting $file\n";

  # unpack package
  if (! -d "$tmpdir") {
    mkdir $tmpdir || die "Could not create directory $tmpdir: $!\n";
  }
  my $DECOMPRESS = ($file =~ /\.gz$/ ? "/bin/gzip -c -d $file" : "cat $file");
  $status = system("$DECOMPRESS | /bin/pkgtrans /dev/fd/0 $tmpdir all 2> /dev/null");
  die "Could not transform $file: $!" if $status;

  foreach (glob "$tmpdir/*") {
    ($pkgname) = (/([\w\+-]+)$/) if (-d);
  }

  open (FILE,"<$tmpdir/$pkgname/pkginfo") || die "Could not open $tmpdir/$pkgname/pkginfo: $!";

  while (my $line = <FILE>) {
    chomp $line;

    # field 1: common name
    if ($line =~ /^NAME=/) {
      ($description,$common) = ($line =~ /=((.+?)\s.*)/);
      next;
    }

    # field 2: version
    if ($line =~ /^VERSION=/) {
      ($version) = ($line =~ /=(.+)$/);
      next;
    }

    # field 3: package name
    if ($line =~ /^PKG=/) {
      ($package) = ($line =~ /=(.+)$/);
      next;
    }

    # field 4: filename
    if (! $pkgfile) {
      ($pkgfile) = ($file =~ /\//) ? ($file =~ /\/(.+)$/) : ($file);
    }

    # field 5: md5 hash
    # Already computed

    # field 6: file size
    if (! $size) {
      $size = (stat($file))[7];
    }

    # field 8: categories
    if ($line =~ /^CSW_CATEGORY=/) {
      ($category) = ($line =~ /=(.+)$/);
      $category = join('|',split(/,\s?/,$category));
      next;
    }
  }
  close FILE;

  # field 7: dependencies
  $deps = $ideps = "";
  if (-r "$tmpdir/$pkgname/install/depend") {
    open (FILE,"<$tmpdir/$pkgname/install/depend");
    while (<FILE>) {
      chomp;
      if (/^P\s+\S/) {
        ($deptmp) = (/P\s+(\S+)/);
        if ($deptmp ne $pkgname && $deptmp ne "SUNW") { # skip if circular or SUNW
          $deps = ($deps) ? "$deps|$deptmp" : $deptmp;
        }
      }
      if (/^I\s+\S/) {
        ($ideptmp) = (/I\s+(\S+)/);
        if ($ideptmp ne $pkgname && $ideptmp ne "SUNW") { # skip if circular or SUNW
          $ideps = ($ideps) ? "$ideps|$ideptmp" : $ideptmp;
        }
      }
    }
    close FILE;
  }

  # clean up
  $status = system("/bin/rm -rf $tmpdir");
  die "Could not delete files in $tmpdir: $!" if $status;

  $deps = "none" unless $deps;
  $category = "none" unless $category;
  $ideps = "none" unless $ideps;
  print CATALOG "$common $version $package $pkgfile $hash $size $deps $category";
  print CATALOG ($format == 9) ? " $ideps\n" : "\n";
  print DESCRIPTIONS "$description\n";
}

close DESCRIPTIONS;
close CATALOG;

unlink "$pkgdir/descriptions";			# May or may not be there
link "$pkgdir/descriptions.new", "$pkgdir/descriptions" or die "Cannot link $pkgdir/descriptions.new to $pkgdir/descriptions: $!";
unlink "$pkgdir/descriptions.new" or die "Cannot unlink $pkgdir/descriptions.new: $!";

unlink "$pkgdir/catalog";			# May or may not be there
link "$pkgdir/catalog.new", "$pkgdir/catalog" or die "Cannot link $pkgdir/catalog.new to $pkgdir/catalog: $!";
unlink "$pkgdir/catalog.new" or die "Cannot unlink $pkgdir/catalog.new: $!";

exit 0;

=head1 NAME

bldcat - build a CSW catalog from packages in a directory.

=head1 SYNOPSIS

bldcat [-fh] <package dir>

=head1 DESCRIPTION

Build a CSW catalog from packages in a directory.

=head1 OPTIONS

=over 5

=item B<-f, --format=x>

Set catalog format. Use 8 for the old 8 field format, default is 9 for the new 9 field format including incompatible packages.

=item B<-h, --help>

Show this help.

=back

=head1 EXAMPLES

=head2 Example 1

C<# bldcat .>

Will build a catalog from packages in the current directory.

=head1 SEE ALSO

http://pkgutil.wikidot.com

http://sourceforge.net/projects/pkgutil

=head1 AUTHOR

Peter Bonivart <bonivart@opencsw.org>

=head1 CREDITS

Dagobert Michelsen

Derek Whayman

For more details, see the readme file.

=head1 COPYRIGHT AND DISCLAIMER

Copyright (C) 2008-2009 Peter Bonivart. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

=cut

