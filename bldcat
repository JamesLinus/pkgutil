#!/usr/bin/env perl -w

# bldcat - build a CSW catalog from packages in a directory
# Copyright (C) 2008-2010 Peter Bonivart

# $Id$

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
#
# The author, Peter Bonivart, can be contacted by email at bonivart@opencsw.org

use strict;
use Getopt::Long;
Getopt::Long::Configure qw(no_ignore_case bundling);

eval { require Digest::MD5; };
die "\nDigest::MD5 not available! Install CSWperl and use that\nfor bldcat. Do that by having /opt/csw/bin before\n/usr/bin in your path.\n" if ($@);

eval { require File::Temp; };
die "\nFile::Temp not available! Install CSWperl and use that\nfor bldcat. Do that by having /opt/csw/bin before\n/usr/bin in your path.\n" if ($@);

my $dir = "/tmp";
my $pkgdir = ".";
my ($deptmp,$status,$pkgname,$ideptmp);
my ($description,$common,$version,$package,$pkgfile,$hash,$size,
    $deps,$category,$help,$ideps);
my %oldcatalog;
my %olddescriptions;
my $format = 9;

GetOptions("h|help"		=> \$help,
           "W|workdir=s"	=> \$dir,
           "f|format=s"		=> \$format) || usage();

usage() if $help;
if (scalar(@ARGV) > 0) {
  $pkgdir = $ARGV[0];
  ($pkgdir) = ($pkgdir =~ /^(.+)\/$/) if ($pkgdir =~ /\/$/);
} else {
  usage();
}

$format = 9 if ($format != 8);

sub usage {
  print <<EOF;
bldcat, build CSW catalogs.

Usage: bldcat [-fWh] <package dir>

  -f, --format=x\tSet catalog format ([8]|9)
  -W, --workdir=x\tSet work directory (default: /tmp)
  -h, --help\t\tShow this help

Written and maintained by Peter Bonivart.
EOF
  exit 1;
}

if (open (CATALOG,"$pkgdir/catalog")) {
  while (<CATALOG>) {
    chomp;
    my @line = split /\s+/;
    my $hash = $line[4];
    $oldcatalog{$hash} = \@line;
  }
  close CATALOG;
}

if (open (DESCRIPTIONS,"$pkgdir/descriptions")) {
  while (<DESCRIPTIONS>) {
    chomp;
    my @line = split /\s+/;
    my $common = $line[0];
    $olddescriptions{$common} = $_;
  }
  close DESCRIPTIONS;
}

open (CATALOG,">$pkgdir/catalog.new") || die "Could not write new catalog at $pkgdir/catalog.new: $!";
open (DESCRIPTIONS,">$pkgdir/descriptions.new") || die "Could not write new descriptions at $pkgdir/descriptions.new: $!";

foreach my $file (glob "$pkgdir/*") {
  ($common,$version,$package,$pkgfile,$hash,$size,$deps,$category,$ideps) = ("","","","","","","","","");
  next unless (-r $file);		# Must be a readable file
  next unless ($file =~ /\.pkg(\.gz)?$/);	# Must end with .pkg or .pkg.gz

  # Calculate hash before we do anything else to look up the cache
  if (! $hash) {
    open (FILE2,"<$file") || die "Could not open $file: $!\n";
    binmode (FILE2);
    $hash = Digest::MD5->new->addfile(*FILE2)->hexdigest;
    close FILE2;
  }

  if (exists $oldcatalog{$hash} && exists $olddescriptions{$oldcatalog{$hash}[0]}) {
    print "Reusing old information for $file\n";
    print CATALOG join(' ', @{$oldcatalog{$hash}}), "\n";
    print DESCRIPTIONS $olddescriptions{$oldcatalog{$hash}[0]}, "\n";
    next;
  }

  print "Inspecting $file\n";

  # Unpack package
  my $tmpdir = File::Temp::tempdir( DIR => $dir, CLEANUP => 1 );
  my $DECOMPRESS = ($file =~ /\.gz$/ ? "/bin/gzip -c -d $file" : "cat $file");
  $status = system("$DECOMPRESS | /bin/pkgtrans /dev/fd/0 $tmpdir all 2> /dev/null");
  die "Could not transform $file: $!" if $status;

  foreach (glob "$tmpdir/*") {
    ($pkgname) = (/([\w\+-\.]+)$/) if (-d);
  }

  open (FILE,"<$tmpdir/$pkgname/pkginfo") || die "Could not open $tmpdir/$pkgname/pkginfo: $!";

  while (my $line = <FILE>) {
    chomp $line;

    # Field 1: common name
    if ($line =~ /^NAME=/) {
      ($description,$common) = ($line =~ /=((.+?)\s.*)/);
      next;
    }

    # Field 2: version
    if ($line =~ /^VERSION=/) {
      ($version) = ($line =~ /=(.+)$/);
      next;
    }

    # Field 3: package name
    if ($line =~ /^PKG=/) {
      ($package) = ($line =~ /=(.+)$/);
      next;
    }

    # Field 4: filename
    if (! $pkgfile) {
      ($pkgfile) = ($file =~ /\//) ? ($file =~ /\/(.+)$/) : ($file);
    }

    # Field 5: md5 hash
    # Already computed

    # Field 6: file size
    if (! $size) {
      $size = (stat($file))[7];
    }

    # Field 8: categories
    if ($line =~ /^CSW_CATEGORY=/) {
      ($category) = ($line =~ /=(.+)$/);
      $category = join('|',split(/,\s?/,$category));
      next;
    }
  }
  close FILE;

  # Field 7: dependencies
  $deps = $ideps = "";
  if (-r "$tmpdir/$pkgname/install/depend") {
    open (FILE,"<$tmpdir/$pkgname/install/depend");
    while (<FILE>) {
      chomp;
      if (/^P\s+\S/) {
        ($deptmp) = (/P\s+(\S+)/);
        if ($deptmp ne $pkgname && $deptmp !~ /^SUNW/) { # Skip if circular or SUNW
          $deps = ($deps) ? "$deps|$deptmp" : $deptmp;
        }
      }
      if (/^I\s+\S/) {
        ($ideptmp) = (/I\s+(\S+)/);
        if ($ideptmp ne $pkgname && $ideptmp !~ /^SUNW/) { # Skip if circular or SUNW
          $ideps = ($ideps) ? "$ideps|$ideptmp" : $ideptmp;
        }
      }
    }
    close FILE;
  }

  $deps = "none" unless $deps;
  $category = "none" unless $category;
  $ideps = "none" unless $ideps;
  print CATALOG "$common $version $package $pkgfile $hash $size $deps $category";
  print CATALOG ($format == 9) ? " $ideps\n" : "\n";
  print DESCRIPTIONS "$description\n";
}

close DESCRIPTIONS;
close CATALOG;

unlink "$pkgdir/descriptions";			# May or may not be there
link "$pkgdir/descriptions.new", "$pkgdir/descriptions" or die "Cannot link $pkgdir/descriptions.new to $pkgdir/descriptions: $!";
unlink "$pkgdir/descriptions.new" or die "Cannot unlink $pkgdir/descriptions.new: $!";

unlink "$pkgdir/catalog";			# May or may not be there
link "$pkgdir/catalog.new", "$pkgdir/catalog" or die "Cannot link $pkgdir/catalog.new to $pkgdir/catalog: $!";
unlink "$pkgdir/catalog.new" or die "Cannot unlink $pkgdir/catalog.new: $!";

exit 0;

=head1 NAME

bldcat - build a CSW catalog from packages in a directory.

=head1 SYNOPSIS

bldcat [-fWh] <package dir>

=head1 DESCRIPTION

Build a CSW catalog from packages in a directory.

=head1 OPTIONS

=over 5

=item B<-f, --format=x>

Set catalog format. Use 8 for the old 8 field format and 9 for the new 9 field format including incompatible packages.

=item B<-W, --workdir=x>

Set work directory. Default /tmp.

=item B<-h, --help>

Show this help.

=back

=head1 EXAMPLES

=head2 Example 1

C<# bldcat .>

Will build a catalog from packages in the current directory.

=head1 SEE ALSO

http://pkgutil.net

http://sourceforge.net/projects/pkgutil

=head1 AUTHOR

Peter Bonivart <bonivart@opencsw.org>

=head1 CREDITS

Maciej Blizinksi

Dagobert Michelsen

Derek Whayman

For more details, see the readme file.

=head1 COPYRIGHT AND DISCLAIMER

Copyright (C) 2008-2010 Peter Bonivart. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

=cut

