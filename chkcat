#!/usr/bin/env perl -w

# chkcat - check that a CSW catalog is consistent
# Copyright (C) 2008-2009 Peter Bonivart

# $Id$

use strict;
use Getopt::Long;
Getopt::Long::Configure qw(no_ignore_case bundling);

eval { require Digest::MD5; };
die "\nMD5 support not available! Install CSWperl and use that\nfor pkgutil. Do that by having /opt/csw/bin before\n/
usr/bin in your path.\n" if ($@);

my @pkglist;
my ($verbose,$hash,$catalog,$status,$deps,$deptmp,$cat,$help,$quiet,
    $erroronly,$pkgver);
my $prefix = ".";
my $tmpdir = "/tmp/chkcat.$$.$^T";
my (%pkg,%pkgdep,%config);
my $rc = 0;
my $format = 8;

GetOptions("v|verbose"		=> \$verbose,
	   "h|help"		=> \$help,
	   "q|quiet"		=> \$quiet,
	   "f|format=s"		=> \$format,
	   "e|erroronly"	=> \$erroronly) || usage();

usage() if $help;
if (scalar(@ARGV) > 0) {
  $catalog = $ARGV[0];
} else {
  usage();
}

if ($format != 9) {
  $format = 8;
}

sub usage {
  print "chkcat, check CSW catalogs for problems.\n\n";
  print "Usage: chkcat [-veqfh] <catalog file>\n";
  print "\n  -v, --verbose\t\tVerbose mode";
  print "\n  -e, --erroronly\tOnly show errors (supress warnings)";
  print "\n  -q, --quiet\t\tNo output (only return codes)";
  print "\n  -f, --format=x\tSet catalog format ([8]|9)";
  print "\n  -h, --help\t\tShow this help\n";
  print "\nWritten and maintained by Peter Bonivart.\n";
  exit 1;
}

sub init {
  my $conf = "/etc/opt/csw/pkgutil.conf";
  if (-r $conf) {
    %config = ("maxpkglist" => "");

    open (CONFIG,"<$conf") or die "Can't open $conf: $!\n";
    while (<CONFIG>) {
      chomp;  # remove newline
      s/#.*//;        # remove comments
      s/^\s+//;       # remove leading white
      s/\s+$//;       # remove trailing white
      next unless length;     # next if nothing left
      my ($var,$value) = split(/\s*=\s*/,$_,2);
      my $r = ref($config{$var});
      if (! $r) {
       $config{$var} = $value;
      } elsif ($r eq 'ARRAY') {
        push(@{$config{$var}},$value);
      }
    }
    close CONFIG;
  }
}

sub retcode {
  my ($rctmp) = @_;

  $rc = $rctmp if ($rctmp > $rc);
}

# read configuration file (/etc/opt/csw/pkgutil.conf)
init();

(-r $catalog) || die "Can't open $catalog";	# must be a readable file

($prefix) = ($catalog =~ /^(.+)\//) if ($verbose && $catalog =~ /\//);

my (@tmp) = `cat $catalog`;

while (scalar(@tmp) > 0) {
  my $line = $tmp[0];
  shift @tmp;
  chomp $line;
  if ($line =~ /-BEGIN PGP SIGNED MESSAGE-/) {
    shift @tmp;
    shift @tmp;
    shift @tmp;
    next;
  }
  last if ($line =~ /-BEGIN PGP SIGNATURE-/);
  next if ($line =~ /^#/);
  my @line = split(/\s+/,$line);
  $pkg{$line[2]} = 1 if ($line[2] =~ /^CSW/);
  $pkgdep{$line[2]} = $line[6];
}

(@tmp) = `cat $catalog`;

while (scalar(@tmp) > 0) {
  my $line = $tmp[0];
  shift @tmp;
  chomp $line;
  my (@field) = split(/ /,$line);

  # if gpg signed catalog, skip a few lines in the beginning
  if ($line =~ /-BEGIN PGP SIGNED MESSAGE-/) {
    print "Skipping signature at start of file.\n" unless ($erroronly || $quiet);
    shift @tmp;
    shift @tmp;
    shift @tmp;
    next;
  }

  # if gpg signature found at the end, exit
  if ($line =~ /-BEGIN PGP SIGNATURE-/) {
    print "\nSkipping signature at end of file.\n" unless ($erroronly || $quiet);
    last;
  }

  # if line starts with a comment, skip
  if ($line =~ /^#/) {
    print "Skipping comment.\n" unless ($erroronly || $quiet);
    next;
  }

  # number of fields
  if (scalar(@field) != $format) {
    retcode(2);
    if (! $quiet) {
      print "\nERROR! ",scalar(@field)," fields instead of normal $format. [$line]\n";
    }
    next;
  }

  # packages that are not compressed, normal for gzip and pkg-get
  if ($field[3] !~ /\.gz$/) {
    retcode(1);
    if (! $erroronly && ! $quiet) {
      print "\nWARNING! Package $field[2] is not compressed. [$line]\n";
    }
  }

  # check the naming standard - http://opencsw.org/standards/build#versioning
  my ($name, $version, $uname, $arch, $footer, $rest) = split /-/, $field[3];
  if (! $footer && $arch) {
    # assume arch is missing - it is optional after all
    $footer = $arch;
    $arch = '';
  }

  if ($arch && ($arch ne 'i386' && $arch ne 'sparc' && $arch ne 'all')) {
    retcode(1);
    if (! $erroronly && ! $quiet) {
      print "\nWARNING! Package $field[2] has an unknown architecture. [$line]\n";
    }
  }

  if ($rest) {
    retcode(1);
    if (! $erroronly && ! $quiet) {
      print "\nWARNING! Package $field[2] does not meet the CSW naming standard - too many hyphens. [$line]\n";
    }
  }

  if ($field[3] !~ /\.pkg(\.gz)?$/) {
    retcode(1);
    if (! $erroronly && ! $quiet) {
      print "\nWARNING! Package $field[2] does not meet the CSW naming standard - should end in .pkg(.gz). [$line]\n";
    }
  }

  if (! $version || $version !~ /[0-9\.]+,REV=(\d{4})\.(\d{2})\.(\d{2})/) {
    retcode(1);
    if (! $erroronly && ! $quiet) {
      print "\nWARNING! Package $field[2] does not meet the CSW naming standard - REV section incorrect. [$line]\n";
    }
  }

  # check that dependency field begins and ends with a word char
  if ($field[6] !~ /^\w/) {
    retcode(2);
    if (! $quiet) {
      print "\nERROR! The dependency field of package $field[2] begins with a non-char. [$line]\n";
    }
  }
  if ($field[6] =~ /\|$/) {	# non-char is actually used, e.g. gcc2g++
    retcode(2);
    if (! $quiet) {
      print "\nERROR! The dependency field of package $field[2] ends with a pipe char. [$line]\n";
    }
  }

  # check that no dependencies are missing
  if ($field[6] ne "none") {
    foreach (split(/\|/,$field[6])) {
      if (! $pkg{$_}) {
        retcode(1);
        print "\nWARNING! Dependency $_ of package $field[2] is missing.\n" unless ($erroronly || $quiet);
      }
    }
  }

  # check for packages that depend on themselves
  if ($field[6] ne "none") {
    foreach (split(/\|/,$field[6])) {
      if ($_ eq $field[2]) {
        retcode(2);
        print "\nERROR! Package $field[2] depends on itself.\n" unless $quiet;
      }
    }
  }

  # check for cyclic dependencies
  my @deplist = ();
  my $deplen = 0;
  push (@deplist,split (/\|/,$field[6])) unless $field[6] eq "none";
  while (scalar(@deplist) > 0) {
    my $tmppkg = $deplist[0];
    shift @deplist;
    if ($tmppkg eq $field[2]) {
      retcode(2);
      print "\nERROR! Cyclic dependency detected in package $field[2].\n" unless $quiet;
      last;
    }
    my $deplenmax = $config{"maxpkglist"} ? $config{"maxpkglist"} : 100000;
    if ($deplen++ > $deplenmax) {
      retcode(1);
      print "\nWARNING! Probable cyclic dependency detected in package $field[2]. Loop detection aborts iteration.\n" unless ($erroronly || $quiet);
      last;
    }
    if ($tmppkg ne "none" && $tmppkg ne "CSWcommon" && $pkgdep{$tmppkg}) {
      my @newdeps = split (/\|/,$pkgdep{$tmppkg});
      push (@deplist,@newdeps);
    }
  }

  # check that category field begins and ends with a word char
  if ($field[7] !~ /^\w/) {
    retcode(2);
    if (! $quiet) {
      print "\nERROR! The category field of package $field[2] begins with a non-char. [$line]\n";
    }
  }
  if ($field[7] !~ /\w$/) {
    retcode(2);
    if (! $quiet) {
      print "\nERROR! The category field of package $field[2] ends with a non-char. [$line]\n";
    }
  }

  # if in verbose mode, check catalog entries against packages if found in
  # same directory as catalog
  if ($verbose) {
    if (! -r "$prefix/$field[3]") {	# does the file exist?
      retcode(2);
      print "ERROR! File $field[3] not found.\n" unless $quiet;
    } else {
      if ($field[5] != (stat("$prefix/$field[3]"))[7]) { # correct size?
        retcode(2);
        print "ERROR! Size does not match for $field[2].\n" unless $quiet;
      }
      open (FILE,"<$prefix/$field[3]");		# MD5 check
      binmode (FILE);
      $hash = Digest::MD5->new->addfile(*FILE)->hexdigest;
      close FILE;
      if ($hash ne $field[4]) {
        retcode(2);
        print "ERROR! MD5 hash does not match for $field[2].\n" unless $quiet;
      }

      # unpack package if depends and/or categories are not "none"
      if (! -d "$tmpdir") {
        mkdir $tmpdir || die "Could not create directory $tmpdir: $!\n";
      }
      $status = system("/bin/gunzip -cf $prefix/$field[3] | /bin/pkgtrans /dev/fd/0 $tmpdir all 2> /dev/null");
      die "Could not transform $field[2]: $!" if $status;

      # check deps against depend file in package
      if ($field[6] ne "none") {
        $deps = "";
        if (-r "$tmpdir/$field[2]/install/depend") {
          open (FILE,"<$tmpdir/$field[2]/install/depend");
          while (<FILE>) {
            chomp;
            if (/^P\s+\w/) {
              ($deptmp) = (/P\s+([\w\+-]+)/);
              $deps = ($deps) ? "$deps|$deptmp" : $deptmp;
            }
          }
        } else {
          print "No depend file found in $field[2]\n" unless $quiet;
        }
        if ($deps ne $field[6]) {
          retcode(2);
          print "ERROR! Dependencies does not match for $field[2].\n" unless $quiet;
        }
      }

      # check categories against pkginfo file in package
      if ($field[7] ne "none") {
        $pkgver = "";
        $cat = "";
        open (FILE,"<$tmpdir/$field[2]/pkginfo");
        while (<FILE>) {
          chomp;
          if (/^CSW_CATEGORY=/) {
            ($cat) = (/=(.+)$/) if (/^CSW_CATEGORY=/);
            $cat = join('|',split(/,\s?/,$cat));
          } elsif (/^VERSION=(\S+)/) {
            $pkgver = $1;
          }
          last if $cat && $pkgver;
        }
      }

      if ($field[7] ne "none") {
        if ($cat ne $field[7]) {
          retcode(2);
          print "ERROR! Categories does not match for $field[2].\n" unless $quiet;
        }
      }

      # check version field matches filename
      if ($pkgver && $version && $pkgver ne $version) {
        retcode(2);
        print "ERROR! version in filename doesn't match version in pkginfo for $field[2].\n" unless $quiet;
      }

      # clean up
      $status = system("/bin/rm -rf $tmpdir");
      die "Could not delete files in $tmpdir: $!" if $status;
    }
  }

  # add package to array for later duplicate check
  push(@pkglist,$field[2]);
}

my @tmplist = sort(@pkglist);
my $dup = "";
while (scalar(@tmplist) > 1) {	# no need to check for dups if only one entry
  my $tmp = $tmplist[0];
  shift @tmplist;
  if ($tmp eq $tmplist[0] && $dup ne $tmp) {
    retcode(2);
    print "ERROR! $tmp exists more than once.\n" unless $quiet;
    $dup = $tmp;
  }
}

exit $rc;

=head1 NAME

chkcat - check CSW catalog for problems

=head1 SYNOPSIS

chkcat [-veqfh] <catalog file>

=head1 DESCRIPTION

Check CSW catalog for problems.

=head1 OPTIONS

=over 5

=item B<-v, --verbose>

Verbose mode. Will compare size, MD5 hash, dependencies and categories specified in catalog against the information in the actual package. The packages must be in the current directory.

=item B<-e, --erroronly>

Only show errors (supress warnings).

=item B<-q, --quiet>

No output (only return codes).

=item B<-f, --format=x>

Set catalog format. Use 8 for the old 8 field format and 9 for the new 9 field format including incompatible packages.

=item B<-h, --help>

Show this help.

=back

=head1 EXAMPLES

=head2 Example 1

C<# chkcat catalog>

Will check catalog for problems.

=head2 Example 2

C<# chkcat -q catalog>

Will supress all output and only generate a return code, 0 for OK, 1 for warnings found and 2 for errors found.

=head1 EXIT STATUS

The following exit values are returned:

	0	OK

	1	Warning

	2	Error

=head1 SEE ALSO

http://pkgutil.wikidot.com

http://sourceforge.net/projects/pkgutil

=head1 AUTHOR

Peter Bonivart <bonivart@opencsw.org>

=head1 CREDITS

Derek Whayman

For more details, see the readme file.

=head1 COPYRIGHT AND DISCLAIMER

Copyright (C) 2008-2009 Peter Bonivart. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

=cut

