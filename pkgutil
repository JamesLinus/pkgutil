#!/usr/bin/env perl -w

# pkgutil - manages packages on Sun Solaris systems
# Copyright (C) 2008-2009 Peter Bonivart

# $Id$

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
#
# The author, Peter Bonivart, can be contacted by email at bonivart@opencsw.org

use strict;
use Getopt::Long;
Getopt::Long::Configure qw(no_ignore_case bundling);

my $debug = 0;
my $pkgutilver = "1.6b1";
my $use_md5 = 0;
my $use_gpg = 0;
my $noncsw = 0;
my @mirror;
my $defaultmirror = ("http://ibiblio.org/pub/packages/solaris/opencsw/current");
my $workdir = "/var/opt/csw/pkgutil";
my $pkgdir;
my $admin;
my ($line,$tmp,$wget,$force,$nomod,$gzip,$name,$ver,$pkgname,$filename,$hash,$size,$deps,$cat,$tmppkg,$tmppkg2);
my (@exclude,%config,%pkg,%commonpkg,%pkgmirror);

chomp(my $arch = `uname -p`);
chomp(my $rel = `uname -r`);

# show available packages in catalog

sub available {
  foreach my $common (sort keys %commonpkg) {
    my $pkgname = $commonpkg{$common};
    foreach my $vers (sort keys %{$pkg{$pkgname}}) {
      my($size) = (split /\s+/, $pkg{$pkgname}{$vers})[5];
      my $tmp = sprintf ("%-20s %-20s %-25s %9s\n",$common,$pkgname,$vers,format_byte($size));
      if ($#ARGV >= 0) {
        foreach (@ARGV) {
          print $tmp if ("$pkgname-$vers" =~ /$_/i || "$common-$vers" =~ /$_/i);
        }
      } else {
         print $tmp;
      }
    }
  }
  exit 0;
}

# check catalog
#   always - always update catalog

sub check_catalog {
  my($always) = @_;

  foreach my $url (@mirror) {
    my $filename = mangle_url($url);
    my $age = 0;
    $age = -M $filename if (-r $filename);
    print "Catalog $url age in days: $age\n" if $debug;
    fetch_catalog($url, $filename) if ($age > 14 || ! -e $filename || $always);
    gpg($filename) if $use_gpg;
    read_catalog($url, $filename); # Once per file
  }
}

# check if package is already installed and if so, which version
#   pkg  - package to check for
#   mode - 0 = return full string, 1 = return only rev part

sub check_pkg {
  my ($pkg,$mode) = @_;
  my ($tmp,$exit_code,$retvalue);

  $tmp = `/bin/pkgparam $pkg VERSION 2> /dev/null`;
  $exit_code = $?;
  chomp $tmp;
  if (! $exit_code) {
    if ($mode == 0) {
      $retvalue = $tmp;
    } else {
      ($retvalue) = ($tmp =~ /REV=(.+)$/);
    }
    print "$pkg installed, version $retvalue\n" if $debug;
  }
  if ($exit_code > 0) {
    $retvalue = "notinst";
    print "$pkg not installed\n" if $debug;
  }
  return $retvalue;
}

# compare current to available packages
#   mode - 0 = print full list, 1 = return list of old packages
#          2 = return full list of old packages

sub compare {
  my ($mode) = @_;
  my (@cswpkgs,@retlist);
  my ($pkg,$local_ver,$remote_ver,$tmp);

  print "package\t\t\t  installed\t\t    catalog\n" if (! $mode);
  if ($noncsw) {
    @cswpkgs = `/bin/pkginfo`;
  } else {
    @cswpkgs = `/bin/pkginfo | grep CSW`;
  }
  foreach $pkg (@cswpkgs) {
    ($pkg) = ($pkg =~ /\s+?(\S+?)\s/);
    $local_ver = check_pkg($pkg,0);
    $remote_ver = parse_catalog($pkg,1);
    $remote_ver = "SAME" if ($local_ver eq $remote_ver);
    if ($mode == 1) {
      push(@retlist,$pkg) if ($remote_ver ne "SAME" && $remote_ver ne "not in catalog");
    } else {
      $tmp = sprintf ("%-25s %-25s %-25s\n",$pkg,$local_ver,$remote_ver);
      if ($mode == 2) {
        push(@retlist,$tmp) if ($remote_ver ne "SAME" && $remote_ver ne "not in catalog");
      } else {
        if ($#ARGV >= 0) {
          foreach (@ARGV) {
            print $tmp if ($pkg =~ /$_/i);
          }
        } else {
          print $tmp;
        }
      }
    }
  } 
  if ($mode) {
    return @retlist;
  } else {
    exit 0;
  }
}

# email notifications when updates are available
#   email - address to send notications to

sub email {
  my ($email) = @_;
  my $file = "/tmp/pkgutil.$$.$^T";

  die "Mailx not found on system!\n" if (! -x "/bin/mailx");
  my @update_list = compare(2);
  if ($#update_list >= 0) {
    open (FILE,">$file") or die "Can't open $file: $!\n";
    foreach (@update_list) {
      print FILE;
    }
    close FILE;
    chomp(my $host = `uname -n`);
    my $subject = "$host: CSW updates available";
    my @args = ("/bin/mailx -s \"$subject\" $email < $file");
    system (@args);
    unlink $file;
  }
  exit 0;
}

# fetch catalog
#   url - url to download from
#   filename - filename to use for local catalog

sub fetch_catalog {
  my($url, $filename) = @_;
  my $wgetopts = "";
  my $status;

  $wgetopts .= " $config{wgetopts}" if $config{wgetopts};
  print "Fetching new catalog $url if available...\n";
  die "Option -n selected, stopping here.\n" if $nomod;

  if ($url =~ /^file:/) {
    my ($tmpcatsrc) = ($url =~ /^file:\/(.+)$/);
    $status = system("/bin/cp $tmpcatsrc/catalog $filename");
  } else {
    $status = system("$wget $wgetopts -O $filename $url/catalog");
  }
  system("/bin/touch $filename") if (-w $filename);
  if ($status) {
    print "\nFetching of catalog failed.\n";
    exit 1;
  }
}

# get wanted package and its dependencies
#   pkglist - packages to fetch
#   mode - 4 = stream silent

sub fetch_pkgs {
  my ($mode,@pkglist) = @_;
  my $wgetopts = "";
  my ($file,$status);
  my $fh = ($mode == 4 ? *STDERR : *STDOUT);

  if ($#pkglist > 0 && ! $force) {
    print $#pkglist + 1 . " packages to fetch. Do you want to continue? [Y,n] ";
    chomp (my $prompt = <STDIN>);
    exit 1 if ($prompt =~ /^[nN]/);
  }
  $wgetopts .= " $config{wgetopts}" if $config{wgetopts};
  foreach (@pkglist) {
    $file = parse_catalog($_,3);
    if (-r "$pkgdir/$file" && -s _ != parse_catalog($_,5)) {	# broken/empty files may be present
      print $fh "Removing non-matching local file.\n";
      unlink "$pkgdir/$file";
    }
    if (-r "$pkgdir/$file") {
      print $fh "A local copy of $_ exists and is of matching size.\n";
    } else {
      print $fh "Fetching $_...\n";
      locate_wget() if (-x $wget);	# if wget disappeared locate alt.
      my $tried;
      foreach (@{$pkgmirror{$file}}) {
        $tried = 1;
        if ($_ =~ /^file:/) {
          my ($tmpcatsrc) = ($_ =~ /^file:\/(.+)$/);
          $status = system("/bin/cp $tmpcatsrc/$file $pkgdir/$file");
        } else {
          $status = system("$wget $wgetopts -O $pkgdir/$file $_/$file");
        }
        last unless $status;
      }
      if ($status || ! $tried) {
        print "\nFetching of $_ failed. Try updating your catalog with pkgutil -U.\n";
        exit 1;
      }
    }
    md5($_,"$pkgdir/$file",$mode) if $use_md5;
  }
}

# format size in bytes to more human friendly format with suffixes
#   size - size in bytes

sub format_byte {
  my ($size) = @_;
  my $suffix = "B";

  if ($size > 1024) {
    $size /= 1024;
    $suffix = "KB";
  }
  if ($size > 1024) {
    $size /= 1024;
    $suffix = "MB";
  }
  if ($size > 1024) {
    $size /= 1024;
    $suffix = "GB";
  }
  return sprintf ("%1.1f %s",$size,$suffix);
}

# check signature on catalog

sub gpg {
  my ($catalog) = @_;
  my $line;
  my $gpg_signed_catalog = 0;

  if (! -x "/opt/csw/bin/gpg") {
    print "GPG not found! Install CSWgnupg or disable use_gpg in pkgutil.conf.\n";
    exit 1;
  }
  open (CATALOG,"<$catalog") or die "Can't open $catalog: $!\n";
  while ($line = <CATALOG>) {
    $gpg_signed_catalog = 1 if ($line =~ /-BEGIN PGP SIGNED MESSAGE-/);
    last;
  }
  close CATALOG;
  print "GPG catalog: $gpg_signed_catalog\n" if $debug;
  if ($gpg_signed_catalog) {
    print "Checking catalog integrity with gpg.\n";
    rename($catalog, $catalog . ".asc") or die "Couldn't rename catalog!\n";
    my $status = system("/opt/csw/bin/gpg $catalog.asc");
    die "Catalog signature is not correct!\n" if $status;
    rename($catalog . ".asc", $catalog) or die "Couldn't rename catalog!\n";
    print "Status GPG: $status\n" if $debug;
  } else {
    print "Catalog $catalog is not signed! Check your mirror settings or disable use_gpg in pkgutil.conf.\n";
    exit 1;
  }
}

# init

sub init {
  my $file;
  my @conf_file = ("/opt/csw/etc/pkgutil.conf","/etc/opt/csw/pkgutil.conf");
  %config = ("mirror"		=> [],
             "pkgaddopts"	=> "",
             "wgetopts"		=> "",
             "use_gpg"		=> "",
             "use_md5"		=> "",
             "noncsw"           => "");

  foreach (@conf_file) {
    if (-r $_) {	# if conf file found, parse it
      print "Conf file: $_\n" if $debug; 
      open (CONFIG,"<$_") or die "Can't open $_: $!\n";
      while (<CONFIG>) {
        chomp;	# remove newline
        s/#.*//;	# remove comments
        s/^\s+//;	# remove leading white
        s/\s+$//;	# remove trailing white
        next unless length;	# next if nothing left
        my ($var,$value) = split(/\s*=\s*/,$_,2);
        print "$var = $value\n" if $debug;
        my $r = ref($config{$var});
        if (! $r) {
         $config{$var} = $value;
        } elsif ($r eq 'ARRAY') {
          push(@{$config{$var}},$value);
        }

      }
      close CONFIG;
    }
  }

  if ($debug) {
    print "mirror: " . join("\t", @{$config{mirror}}) . "\n";
    print "pkgaddopts: $config{pkgaddopts}\n";
    print "wgetopts: $config{wgetopts}\n";
    print "use_gpg: $config{use_gpg}\n";
    print "use_md5: $config{use_md5}\n";
    print "noncsw: $config{noncsw}\n";
  }

  $use_md5 = 1 if ($config{use_md5} eq "true");
  $use_gpg = 1 if ($config{use_gpg} eq "true");
  $noncsw = 1 if ($config{noncsw} eq "true" || $config{noncsw} eq "yes");
}

# install packages
#   pkglist - packages to install

sub inst_pkgs {
  my @pkglist = @_;
  my $tmp = "";
  my $pkgadd = "/usr/sbin/pkgadd";
  my $pkgaddopts = "";
  my $pkgrm = "/usr/sbin/pkgrm";
  my $file;
  my $name;
  my $pkgforce = "";

  $pkgaddopts .= " $config{pkgaddopts}" if $config{pkgaddopts};
  $pkgforce = "-a $admin -n" if $force;
  foreach (@pkglist) {
    my ($pkgname) = ($_ =~ /^(.+)-/);
    $tmp = check_pkg($pkgname,0);
    if ($tmp ne "notinst") {
      print "Removing old version of $pkgname\n";
      `$pkgrm $pkgforce $pkgname`;
    }
    $file = parse_catalog($_,3);
    $name = parse_catalog($_,2);
    print "Installing $_\n";
    if ($file =~ /\.gz$/) {		# not all packages are compressed
      my $status = locate_gzip();
      if (! $status) {
        if ($force) {
          `$gzip -f -d $pkgdir/$file`;
        } else {
          `$gzip -d $pkgdir/$file`;
        }
      } else {
        print "\nGzip not found, please install CSWgzip.\n";
        exit 1;
      }
      ($file) = ($file =~ /(.+)\.gz$/);
    }
    `$pkgadd $pkgforce $pkgaddopts -d $pkgdir/$file $name`;
    unlink("$pkgdir/$file") or die "Can't delete $pkgdir/$file: $!\n";
  }
}

# install (-i) option
#   mode - 0 = install, 1 = download only, 2 = remove, 3 = stream,
#          4 = stream silent

sub install {
  my ($mode) = @_;
  my $retvalue;
  my (@tmppkglist,@revpkglist,@newpkglist,@instpkglist,@updpkglist,@curpkglist,@dlpkglist);
  my $fh = ($mode == 4 ? *STDERR : *STDOUT);
  my(%pkgvers, @pkglist); # @pkglist is specifically in the correct order.

  print $fh "Parsing catalog, may take a while...\n";
  foreach my $tmppkg (@ARGV) {
    my $tmp = parse_catalog($tmppkg,2);
    my $vers = parse_catalog($tmppkg,1);
    if ($tmp ne 'not in catalog' && ($tmp =~ /^CSW/ || $noncsw)) {
      push(@pkglist,$tmp);
      $pkgvers{$tmp} = $vers;
    } else {
      print "Package $tmppkg not in catalog...exiting.\n";
      exit 1;
    }
  }
  foreach my $tmppkg2 (@pkglist) {
    # N.B. This array grows and we keep looping until we've satisfied all
    # of the dependencies.
    my @tmpdeps;
    if ($tmppkg2 ne "CSWcommon") {
      $retvalue = parse_catalog($tmppkg2,6);
      if ($retvalue eq "not in catalog") {
        system("pkginfo -q $tmppkg2");
        next if $? == 0;	# already installed... forgive its absence from the catalog
        print "Package $tmppkg2 not in catalog...exiting.\n";
        exit 1;
      } else {
        @tmpdeps = split(/\|/,$retvalue);
        print "depmap: $tmppkg2 -> ", $retvalue, "\n" if $debug;
      }
    } else {
      next;
    }
    if ($tmpdeps[0] ne "none") {
      foreach my $dep (@tmpdeps) {
        # there is no support for dependencies against a particular version, e.g. CSWzope-3.3.1, just CSWzope
        if (! exists $pkgvers{$dep}) {
          $pkgvers{$dep} = parse_catalog($dep,1);
	}
        push(@pkglist,$dep);	# append to list, does not include deduplication
      }
    }
    next;
  }
  print "pkglist ", join(",", @pkglist), "\n" if $debug;

  # clean list from excludes.  Delete from the %pkgvers hash:
  foreach my $pkg (@exclude) {
    delete $pkgvers{$pkg} if exists $pkgvers{$pkg};
  }

  # now reverse and deduplicate @pkglist.  Need the last instance of each
  # package if reading @pkglist forwards.
  my %deduped;
  for my $pkg (reverse @pkglist) {
    next unless $pkgvers{$pkg}; # not if excluded
    unless (exists $deduped{$pkg}) {
	push @revpkglist, $pkg;
	$deduped{$pkg} = 1;
    }
  }

  if ($mode == 2) {		# if -r used
    if ($#revpkglist >= 0) {
      rem_pkgs(reverse @revpkglist);
    }
  }
  print "revpkglist ", join(",", @revpkglist), "\n" if $debug;

  # which packages do we really need to download?

  if ($mode != 3 && $mode != 4) {
    foreach (@revpkglist) {
      my $old = check_pkg($_,0);
      my $new = $pkgvers{$_};
      if ($old eq "notinst") {	# new package needed
        push(@newpkglist,"$_-$new");
      } else {			# package already installed
        if (verscmp($new,$old) == 1) {
          push(@updpkglist,"$_-$new");	# updated package needed
        } else {
          push(@curpkglist,"$_-$old");	# package is current
        }
      }
    }
  } else {	# if -s or -d then just copy revpkglist to newpkglist
    foreach (@revpkglist) {
      push(@newpkglist,"$_-$pkgvers{$_}");
    }
  }

  if ($#newpkglist >= 0) {
    print $fh "New packages: ", join(" ", @newpkglist), "\n";
  }

  if ($mode != 3 && $mode != 4) {	# not needed if -s
    if ($#updpkglist >= 0) {
      print "Updated packages: ", join(" ", @updpkglist), "\n";
    }

    if ($#curpkglist >= 0) {
      print "Current packages: ", join(" ", @curpkglist), "\n";
    }
  }

  # what packages do we need to fetch?

  push(@dlpkglist,@newpkglist);
  push(@dlpkglist,@updpkglist);
  print "dlpkglist ", join(",", @dlpkglist), "\n" if $debug;

  # print size of download

  if ($#dlpkglist >= 0) {
    foreach (@dlpkglist) {
      $size += parse_catalog($_,5);
    }
    print $fh "Total size: " . format_byte($size) . "\n";
  }

  die "Option -n selected, stopping here.\n" if ($nomod);

  if ($#dlpkglist >= 0) {
    fetch_pkgs($mode,@dlpkglist);
  }

  return @revpkglist if ($mode == 3 || $mode == 4);	# is -s used

  if ($mode == 0) {		# if -d not used, install
    if ($#dlpkglist >= 0) {
      inst_pkgs(@dlpkglist);
    }
  }
  exit 0;
}

# find gzip

sub locate_gzip {
  my @locations = ("/opt/csw/bin","/bin","/usr/local/bin");

  foreach (@locations) {
    if (-x "$_/gzip") {
      $gzip = "$_/gzip";
      last;
    }
  } 
  print "gzip: $gzip\n" if $debug;
  return 1 if (! $gzip);
}

# find wget

sub locate_wget {
  my @locations = ("/opt/csw/bin","/usr/sfw/bin","/usr/local/bin");
  my $libexec = "/opt/csw/libexec/pkgutil";

  foreach (@locations) {
    if (-x "$_/wget") {
      $wget = "$_/wget";
      last;
    }
  } 
  if (! $wget) {
    $wget = "$libexec/wget" if (-x "$libexec/wget");
  }
  print "wget: $wget\n" if $debug;
  return 1 if (! $wget);
}

# make a filename from the URL - /es to _es.
#   url - url to mangle

sub mangle_url {
  my($url) = @_;

  (my $mangled = $url) =~ s?\w+://??;
  $mangled =~ s?/?_?g;
  my $filename = "$workdir/catalog.$mangled";
  return $filename;
}

# check md5 on downloaded files
#   mode - 4 = stream silent

sub md5 {
  my ($pkg,$file,$mode) = @_;
  my $md5;
  my $fh = ($mode == 4 ? *STDERR : *STDOUT);

  eval { require Digest::MD5; };
  if ($@) {
    if (-x "/opt/csw/bin/gmd5sum") {
      die "Can't open $file: $!\n" unless (-r $file);
      $md5 = `/opt/csw/bin/gmd5sum $file`;
      ($md5) = ($md5 =~ /^(.*\w) /);
    } else {
      print "\nMD5 support not available! Install CSWtextutils to get MD5\n";
      print "support. Another alternative is to install CSWperl and use\n";
      print "that for pkgutil. Do that by having /opt/csw/bin before\n";
      print "/usr/bin in your path.\n";
      exit 1;
    }
  } else {
    open (FILE,"<$file") or die "Can't open $file: $!\n";
    binmode (FILE);
    $md5 = Digest::MD5->new->addfile(*FILE)->hexdigest;
    close FILE;
  }
  my $md5cat = parse_catalog($pkg,4);
  print "$pkg md5 file: $md5\n$pkg md5 cat:  $md5cat\n" if $debug;
  die "MD5 for $pkg doesn't match catalog!" if ($md5 ne $md5cat);
  print $fh "MD5 for $pkg matched.\n";
}

# parse catalog
#   pkg  - package to look for, can be both common name and true name
#   mode - what we want to return, field number from catalog

sub parse_catalog {
  my ($pkg,$mode) = @_;
  my ($retvalue, $name);

  print "Parsing catalog...looking for: $pkg (mode $mode)\n" if $debug;

  # do we have an embedded version?
  my @p = split /-/, $pkg;
  my $vers = pop @p;
  my $tryname = join('-', @p);

  # first check the whole name without stripping off a "version"
  # e.g. CSWdovecot-devel:
  if ($pkg{$pkg}) {
    # SysV, no version (e.g. CSWdovecot-devel)
    $name = $pkg;
    undef $vers;
  } elsif ($commonpkg{$pkg} && $pkg{$commonpkg{$pkg}}) {
    # Common (e.g. dovecot_devel)
    $name = $commonpkg{$pkg};
    undef $vers;
  } elsif ($pkg{$tryname}) {
    # SysV, version (e.g. CSWdovecot-devel-1.0.13,REV=2008.03.16)
    $name = $tryname;
  } elsif ($commonpkg{$tryname} && $pkg{$commonpkg{$tryname}}) {
    # Common (e.g. dovecot_devel-1.0.13,REV=2008.03.16)
    $name = $commonpkg{$tryname};
  }

  if ($name) {
    # have we a version match?
    if ($vers && exists $pkg{$name}{$vers}) {
      $retvalue = (split(/ /,$pkg{$name}{$vers}))[$mode];
    } elsif (! $vers) {
      # we may have multiple versions in the catalog, take the highest
      # note this won't work unless at least one has a REV in it
      my $highest = (sort { verscmp($b, $a) } keys %{$pkg{$name}})[0];
      $retvalue = (split(/ /,$pkg{$name}{$highest}))[$mode];
    } else {
      $retvalue = "not in catalog" if (! $retvalue);
    }
  } else {
    $retvalue = "not in catalog" if (! $retvalue);
  }
  print "Return value: $retvalue\n" if $debug;
  return $retvalue;
}

# parse command line

sub parse_cl {
  my ($opt_install,$opt_upgrade,$opt_remove,$opt_download,$opt_avail,
      $opt_compare,$opt_upd_cat,$opt_email,@opt_temp,$opt_help,$opt_version,
      $opt_syscheck,$opt_stream,$opt_target,$opt_output,$opt_workdir);

  usage() if (@ARGV == 0);
  GetOptions("i|install"	=> \$opt_install,
             "u|upgrade"	=> \$opt_upgrade,
             "r|remove"		=> \$opt_remove,
             "d|download"	=> \$opt_download,
             "a|available"	=> \$opt_avail,
             "c|compare"	=> \$opt_compare,
             "U|catalog"	=> \$opt_upd_cat,
             "e|email=s"	=> \$opt_email,
             "t|temp=s"		=> \@opt_temp,
             "y|yes"		=> \$force,
             "s|stream"		=> \$opt_stream,
             "T|target=s"	=> \$opt_target,
             "o|output=s"	=> \$opt_output,
             "x|exclude=s"	=> \@exclude,
             "W|workdir=s"	=> \$opt_workdir,
             "n|nomod"		=> \$nomod,
             "D|debug"		=> \$debug,
             "h|help"		=> \$opt_help,
             "v|version"	=> \$opt_version,
             "V|syscheck"	=> \$opt_syscheck) || usage();

  usage() if $opt_help;
  locate_wget();
  locate_gzip();
  if ($opt_workdir) {	# set/create optional working dir
    $workdir = $opt_workdir;
    print "new workdir: $workdir\n" if $debug;
  }
  $pkgdir = "$workdir/packages";
  $admin = "$workdir/admin";
  my $status = system("/bin/mkdir -p $pkgdir");
  die "Could not create $pkgdir: $!" if $status;

  pkgutilver(0) if $opt_version;
  pkgutilver(1) if $opt_syscheck;
  # Get mirrors together
  @mirror = @{$config{mirror}};
  $mirror[0] = $defaultmirror unless @mirror; # if no mirrors configured
  # Prepend temp mirrors so they are selected first
  unshift @mirror, @opt_temp if @opt_temp;

  foreach (my $i=0; $i < scalar @mirror; $i++) {
    ($mirror[$i]) = ($mirror[$i] =~ q!^(.+\w)!);
    $mirror[$i] .= "/" . $arch . "/" . $rel;
  }
  print "primary mirror: $mirror[0]\n" if $debug;
  if ($opt_upd_cat || @opt_temp) {
    check_catalog(1);	# Reread everything
  } else {
    check_catalog();
  }
  stream($opt_target,$opt_output) if $opt_stream;
  email($opt_email) if $opt_email;
  available() if $opt_avail;
  compare(0) if $opt_compare;
  install(0) if $opt_install;
  install(2) if $opt_remove;		# remove instead of install
  install(1) if $opt_download;		# download only

  # upgrade is a special case of install

  if ($opt_upgrade) {
    if (@ARGV == 0 || $ARGV[0] eq "all" || $ARGV[0] eq "ALL") {
      # need to manipulate ARGV to match installed CSW packages
      # that need upgrading (use -c mode 1)
      print "Looking for packages that can be upgraded...\n";
      my @cswpkgs = compare(1);
      my $i = 0;
      foreach (@cswpkgs) {
        $ARGV[$i++] = $_;
      }
    }
    install(0);
  }

  # arguments but no options
  print "You need to select an option!\n" if (! $opt_upd_cat);
}

# show version info
#   mode - 0 = print only version, 1 = system check

sub pkgutilver {
  my ($mode) = @_;
  my $flag = 0;
  chomp(my $solver = `uname -r`);
  chomp(my $solarch = `uname -p`);
  my ($pkgpatch,$pkgpatchinst);

  if ($mode) {
    print "Pkgutil\t\t$pkgutilver\n";
    print "Arch\t\t$solarch\n";
    print "Solaris\t\t$solver\n";
    $pkgpatch = ($solarch eq "sparc") ? "110934" : "110935" if ("$solver" eq "5.8");
    $pkgpatch = ($solarch eq "sparc") ? "113713" : "114568" if ("$solver" eq "5.9");
    $pkgpatch = ($solarch eq "sparc") ? "119317" : "119318" if ("$solver" eq "5.10");
    if ($solver ne "5.11") {
      chomp($pkgpatchinst = `showrev -p | grep $pkgpatch | cut -d' ' -f2 | grep $pkgpatch | sort | tail -1`);
      $pkgpatchinst = ($pkgpatchinst) ? "$pkgpatchinst installed" : "not found";
    } else {
      $pkgpatch = $pkgpatchinst = "na";
    }
    print "Pkg patch\t$pkgpatch ($pkgpatchinst)\n";
    if (-x "/opt/csw/bin/gpg") {
      print "GPG binary\t/opt/csw/bin/gpg\n";
    } else {
      print "GPG binary\tnot found (suggestion: install CSWgnupg)\n";
    }
    my $status = locate_gzip(); 
    print "Gzip binary\t" . (($status) ? "not found (suggestion: install CSWgzip)" : $gzip) . "\n";
    if (-x "/bin/mailx") {
      print "Mailx binary\t/bin/mailx\n";
    } else {
      print "Mailx binary\tnot found (option --email not available)\n";
    }
    if (-x "/opt/csw/bin/gmd5sum") {
      print "MD5 binary\t/opt/csw/bin/gmd5sum\n";
    } else {
      print "MD5 binary\tnot found";
      print " (suggestion: install CSWtextutils)" unless $flag;
      print "\n";
      $flag = 0;
    }
    eval { require Digest::MD5; };
    if ($@) {
      print "MD5 module\tnot found\n";
    } else {
      print "MD5 module\t",Digest::MD5->VERSION," (primary choice for MD5)\n";
      $flag = 1;
    }
    print "Perl\t\t$]\n";
    print "Perl binary\t" . `which perl`;
    $status = locate_wget(); 
    print "Wget binary\t" . (($status) ? "not found (suggestion: install CSWwget)" : $wget) . "\n";
    print "PATH\t\t$ENV{PATH}\n";
  } else {
    print "$pkgutilver\n";
  }
  exit 0;
}

# read catalog into hash
#   catalog - catalog to read
#   filename - filename to use

sub read_catalog {
  my($catalog, $filename) = @_;
  my @llst;

  open (CATALOG,"<$filename") or die "Can't open $filename: $!\n";
  while (my $line = <CATALOG>) {
    chomp $line;
    if ($line =~ /^\w/) {
      @llst = split(/ /,$line);
      if ($llst[0] && $llst[1] && $llst[2] && $llst[3] && $llst[4] && $llst[5] && $llst[6] && $llst[7]) {
        $pkg{$llst[2]}{$llst[1]} = $line;
        $commonpkg{$llst[0]} = $llst[2];
        push(@{$pkgmirror{$llst[3]}},$catalog);
      }
    }
  }
  close CATALOG;
}

# remove packages
#   pkglist - packages to remove

sub rem_pkgs {
  my @pkgs = @_;
  my $retval = "";
  my $pkgrm = "/usr/sbin/pkgrm";
  my $pkgforce = "";
  my ($pkg,$i,$j,$k,$l,$depinuse,$skip);
  my (@cswpkgs,@deptmp,@rempkgs);

  $pkgforce = "-a $admin -n" if $force;
  print "Looking at installed CSW packages...\n";
  my @cswpkgstmp = `/bin/pkginfo | grep CSW`;
  foreach $pkg (@cswpkgstmp) {
    ($pkg) = ($pkg =~ /\s+?(\w+?)\s/);
    $skip = 0;
    foreach (@pkgs) {
      $skip = 1 if ($_ eq $pkg);
    }
    push(@cswpkgs,$pkg) unless $skip;
  }
  print "Examining dependencies for:\n";
  foreach $i (@pkgs) {
    print "  $i";
    $depinuse = 0;
    foreach $j (@cswpkgs) {
      $retval = parse_catalog($j,6);
      if ($retval ne "none" && $i ne $j) { 
        (@deptmp) = split(/\|/,$retval);
        foreach $k (@deptmp) {
          if ($k eq $i) {
            print "\n$i is in use by $j\n" if $debug;
            $depinuse = 1;
            last;
          }
        }
      }
      $depinuse ? last : next;
    }
    push(@rempkgs,$i) unless $depinuse;
    $depinuse ? print " (in use)\n" : print " (remove)\n";
  }
  if ($#rempkgs > 0 && ! $force) {
    print $#rempkgs + 1 . " packages to remove. Do you want to continue? [Y,n] ";
    chomp (my $prompt = <STDIN>);
    exit 1 if ($prompt =~ /^[nN]/);
  }
  if ($#rempkgs >= 0) {
    foreach (@rempkgs) {
      $retval = check_pkg($_,0);
      if ($retval ne "notinst") {
        die "Option -n selected, stopping here.\n" if ($nomod);
        print "Removing $_\n";
        `$pkgrm $pkgforce $_`;
      }
    }
  } else {
    print "Nothing to remove.\n";
  }
  exit 1;
}

# build package streams
#   target - arch and os release
#   output - file name for package stream

sub stream {
  my ($target,$output) = @_;
  my @supp_arch = qw(sparc i386);
  my @supp_rel = qw(5.8 5.9 5.10 5.11);
  my ($fh,$mode,$arch,$rel,$transfile);
  my ($ok_arch,$ok_rel) = (0,0);

  if ($output) {
    $fh = ($output eq "-" ? *STDERR : *STDOUT);
    $mode = ($output eq "-" ? 4 : 3);
  } else {
    $fh = *STDOUT;
    $mode = 3;
  }
 
  if ($target) {
    if ($target =~ /.:./) {
      ($arch,$rel) = split(/:/,$target);
    } else {
      print "$target is not a correct arch:rel combo.\n";
      exit 1;
    }
  } else {
    chomp($arch = `uname -p`);	# arch type sparc|i386
    chomp($rel = `uname -r`);	# os version, e.g. 5.10
  }
  print "arch: $arch\nos rel: $rel\n" if $debug;

  foreach (@supp_arch) {
    if ($arch eq $_) {
      $ok_arch = 1;
      last;
    }
  }
  foreach (@supp_rel) {
    if ($rel eq $_) {
      $ok_rel = 1;
      last;
    }
  }
  print "Architecture $arch not supported.\n" if (! $ok_arch);
  print "OS release $rel not supported.\n" if (! $ok_rel);
  exit 1 if (($ok_arch + $ok_rel) < 2);

  if ($output) {
    $transfile = ($output eq "-" ? "/dev/fd/1" : "$pkgdir/$output");
  } else {
    $output = "$ARGV[0].$arch.$rel.pkg";
    $transfile = "$pkgdir/$output";
  }
  print STDERR "output: $output\ntransfile: $transfile\n" if $debug;

  my @install_order = install($mode);	# download packages needed
  exit 1 if ($#install_order < 0);	# empty list, nothing to do
  my $pkglist = join(' ',@install_order);
  print "install order: $pkglist\n" if $debug;

  foreach (@install_order) {		# pkgtrans them one by one
    my $file = parse_catalog($_,3);
    print $fh "Transforming $_...\n";
    my $status = system("$gzip -c -f -d $pkgdir/$file | /bin/pkgtrans /dev/fd/0 $pkgdir all 2> /dev/null");
    die "Could not transform $file: $!" if $status;
  }

  # pkgtrans all of them into one package stream
  print $fh "Transforming packages into stream...\n";
  my $status = system("/bin/pkgtrans -s $pkgdir $transfile all 2> /dev/null");
  die "Could not transform packages into stream: $!" if $status;

  foreach (@install_order) {		# delete package directories
    my $status = system("/bin/rm -rf $pkgdir/$_");
    die "Could not delete $pkgdir/$_: $!" if $status;
  }

  # print cmd needed to install
  print $fh "\nInstall commands in dependency safe order:\n\n";
  foreach (@install_order) {
    print $fh "pkgadd -d $output $_\n";
  }

  exit 0;
}

# show usage info

sub usage {
  print "Pkgutil $pkgutilver, install Solaris packages the easy way.\n\n";
  print "Usage: pkgutil [option]... [package](-[version])...\n";
  print "\n  -i, --install\t\tInstall package";
  print "\n  -u, --upgrade\t\tUpgrade package";
  print "\n  -r, --remove\t\tRemove package (experimental)";
  print "\n  -d, --download\tDownload only";
  print "\n  -a, --available\tShow available packages";
  print "\n  -c, --compare\t\tCompare installed packages to current";
  print "\n  -U, --catalog\t\tUpdate catalog";
  print "\n  -e, --email=address\tSend e-mail with available updates";
  print "\n  -t, --temp=site\tTemporarily use this site as primary for download";
  print "\n  -s, --stream\t\tBuild a package stream";
  print "\n  -T, --target=arch:rel\tSpecify architecture and OS release for stream";
  print "\n  -o, --output=file\tFile name for package stream (used with -s)";
  print "\n  -x, --exclude=package\tPackage to exclude";
  print "\n  -W, --workdir=path\tPath to use for downloads";
  print "\n  -y, --yes\t\tAnswer yes on all prompts";
  print "\n  -n, --nomod\t\tNo modifications are made to the system";
  print "\n  -D, --debug\t\tDebug mode";
  print "\n  -h, --help\t\tShow this help";
  print "\n  -v, --version\t\tShow version";
  print "\n  -V, --syscheck\tSystem check\n";
  print "\nExample: pkgutil -i CSWwget\ (install wget and its dependencies)\n";
  print "\nWritten and maintained by Peter Bonivart.\n";
  exit 0;
}

# comparison of two package versions as per
# http://pkgutil.wikidot.com/get-install-and-configure#toc7
# as per cmp or <=>, -1, 0, or 1 if p1 is less than, equal to or greater than p2
# Note that if neither has a REV code, -1 is *ALWAYS* returned.
#   p1rev, p2rev - versions to compare

sub verscmp {
  my($p1rev,$p2rev) = @_; # crev (new), irev (old), then 1 => upgrade
  my (@p1list,@p2list);
  my $p1tmp = "";
  my $p2tmp = "";
  my $update = 0;

  my $skip = 0;

  # 1st case: same strings => no upgrade
  $skip = 1 if ($p1rev eq $p2rev);

  # 2nd case: installed no REV, catalog REV => upgrade
  if (! $skip) {
    if ($p1rev !~ /REV=/ && $p2rev =~ /REV=/) {
      $update = -1;
      $skip = 1;
    } elsif ($p2rev !~ /REV=/ && $p1rev =~ /REV=/) {
      # Reverse case (intalled REV, catalog no REV => "downgrade")
      $update = 1;
      $skip = 1;
    }
  }

  # 3rd case: installed REV, catalog REV => if newer, upgrade
  if (! $skip) {
    if ($p1rev =~ /REV=/ && $p2rev =~ /REV=/) {
      if ($p1rev =~ /rev=/) {
        ($p1tmp) = ($p1rev =~ /REV=(.+)_/);
      } else {
        ($p1tmp) = ($p1rev =~ /REV=(.+)$/);
      }
      @p1list = split(/\./,$p1tmp);

      if ($p2rev =~ /rev=/) {
        ($p2tmp) = ($p2rev =~ /REV=(.+)_/);
      } else {
        ($p2tmp) = ($p2rev =~ /REV=(.+)$/);
      }
      @p2list = split(/\./,$p2tmp);

      for (my $i = 0; $i <= $#p1list; $i++) {
        if (! $p2list[$i]) {
          $update = 1;
          last;
        }
        if ($p1list[$i] != $p2list[$i]) {
          if ($p1list[$i] > $p2list[$i]) {
            $update = 1;
          } else {
            $update = -1;
          }
          print "$i $p1list[$i] $p2list[$i] $update\n" if $debug;
          last;
        }
        print "$i $p1list[$i] $p2list[$i] $update\n" if $debug;
      }
      $update = -1 if (! $update && $#p2list > $#p1list);

      $skip = 1;
    }
  }

  # 4th case: installed no REV, catalog no REV => upgrade
  if (! $skip) {
    $update = 1 if ($p1rev !~ /REV=/ && $p2rev !~ /REV=/);
  }

  return $update;
}

# main

init();
parse_cl();

exit 0;

=head1 NAME

pkgutil - install Solaris packages the easy way

=head1 SYNOPSIS

pkgutil [option]... [package]...

=head1 DESCRIPTION

Pkgutil, written in Perl and licensed under GPL, is a tool to make installation of packages in Solaris easier.

It handles package dependencies so all required packages are installed before the desired package automatically.

A catalog is used to make this possible. The format is:

S<common_name version package_name file_name md5_hash pkg_size dependencies category>

Example:

S<bind 9.4.2,REV=2008.07.09_rev=p1 CSWbind bind-9.4.2,REV=2008.07.09_rev=p1-SunOS5.8-sparc-CSW.pkg.gz f68df57fcf54bfd37304b79d6f7eeacc 2954112 CSWcommon|CSWosslrt net>

In the example CSWbind has two dependencies separated by a pipe. Multiple categories can also be separated by pipe characters.

=head1 OPTIONS

=over 5

=item B<-i, --install>

Install package. Will install the specified packages with all their dependencies.  You may specify an explicit version (e.g. amarok-1.4.8,REV=2008.02.26) if desired, otherwise the latest version found is chosen.

=item B<-u, --upgrade>

Upgrade package. A special argument is "all" which will upgrade all installed packages if possible, no argument is the same as "all". If one or more packages are given as arguments only those will be upgraded.

=item B<-r, --remove>

Remove package. This will remove a package including all dependencies that are not in use by other packages.

=item B<-d, --download>

Download only. Same as install but stops after downloading the packages.

=item B<-a, --available>

Show available packages.

=item B<-c, --compare>

Compare installed packages to current.

=item B<-U, --catalog>

Update catalog.

=item B<-e, --email=address>

Send e-mail with available updates. E-mail address as argument. Don't use with other options.

=item B<-t, --temp=site>

Temporarily use this site for download. Must be the complete url where to find the catalog and associated packages. May be specified multiple times.

=item B<-s, --stream>

Build a package stream for a certain architecture and OS release. All dependencies will be included in the stream and the needed command to install them in the correct order will be displayed.

=item B<-T, --target=arch:rel>

Specify architecture and OS release for stream, e.g. i386:5.9 or sparc:5.10. Used with -s. If not specified defaults to architecture and release of the host running pkgutil.

=item B<-o, --output=file>

File name for package stream. Used with -s. A special argument is "-" which sends the stream to standard output, see example below.

=item B<-x, --exclude=package>

Package to exclude. This option can be specified multiple times.

=item B<-W, --workdir=path>

Path to use for downloads. This can be used to run pkgutil as non-root, e.g. called from a web server.

=item B<-y, --yes>

Answer yes on all prompts. Skips prompt when multiple packares are to be downloaded. Makes pkgrm/pkgadd operations more silent and without prompts. Only makes sense with -i and -u.

=item B<-n, --nomod>

No modifications are made to the system. Stops before downloading catalog/packages. Use it to simulate if catalog needs updating or which packages will be downloaded. Only makes sense with -i, -u and -U.

=item B<-D, --debug>

Debug mode. Adds a lot of info about what's going on. Only use if you're having problems you think is a bug.

=item B<-h, --help>

Show this help.

=item B<-v, --version>

Show pkgutil version.

=item B<-V, --syscheck>

System check. This shows info about binaries and more that pkgutil needs to support all features.

=back

=head1 EXAMPLES

=head2 Example 1

C<# pkgutil -i CSWbind>

Will install CSWbind with all required dependencies.

=head2 Example 2

C<# pkgutil -e nobody@foo.bar>

Will run silently and send an e-mail (with mailx) to the given address if there's updated packages available. Run it from crontab once weekly.

=head2 Example 3

C<# pkgutil -y -o - -s bind | gzip > bind.pkg.gz>

Will send a package stream including all dependencies needed for CSWbind to standard output which is piped to gzip. With "-o -" the normal output is sent to standard error and "-y" is used to skip the confirmation prompt.

=head2 Example 4

C<# pkgutil -T i386:5.10 -s bind>

Will make a package stream including all dependencies needed for CSWbind. The package stream will contain packages for the i386 architecture and Solaris 10 regardless of host used to run pkgutil.

=head1 CONFIGURATION

Pkgutil uses a configuration file, pkgutil.conf, that contains a few important settings. No modifications are mandatory though since pkgutil will happily run with the defaults.

Pkgutil will look for pkgutil.conf in /opt/csw/etc but the primary location is /etc/opt/csw. If no pkgutil.conf is found in either of those two locations defaults are used.

The settings that can be used are:

C<mirror>

This is the mirror that is used for downloading the catalog and packages. Try setting it to your nearest mirror to improve download speed. This option may be specified multiple times.

It also supports (in an experimental way) the file:// protocol for local/NFS mirrors. Example: C<mirror=file:///absolute/path/to/files>

C<pkgaddopts>

Send options to pkgadd, one example is -G that will only install the packages in the global zone for Solaris 10.

C<wgetopts>

Send options to wget, for example to show more or less information during downloads.

C<use_gpg>
C<use_md5>

These two can enable (default is disabled for both) checking the catalogs integrity (GPG) and that each downloaded file is unchanged from the published one (MD5). To use GPG you need CSWgnupg installed. MD5 is supported by default in Solaris 10 and on Solaris 8 and 9 if you have CSWperl installed and have /opt/csw/bin first in your path. You can also install CSWtextutils to get MD5 support.
 
C<noncsw>

Enable (default is disable) support for non-CSW prefixed packages.

Pkgutil also uses a file to configure pkgadd when the yes (-y) option is used. This file is located in /var/opt/csw/pkgutil and is called admin. It's by default set up to fully automate installations but if you change something in this file it will be preserved during upgrades of pkgutil. Read more about the admin file with "man -s4 admin".

=head1 SEE ALSO

http://pkgutil.wikidot.com

http://pkgutil.sourceforge.net

=head1 TODO

Some functionality and lots of error handling.

=head1 AUTHOR

Peter Bonivart <bonivart@opencsw.org>

=head1 CREDITS

Dennis Clarke

Ivo De Decker

Ihsan Dogan

Sebastian Kayser

James Lee

Dagobert Michelsen

Yann Rouillard

Derek Whayman

For more details, see the readme file.

=head1 COPYRIGHT AND DISCLAIMER

Copyright (C) 2008-2009 Peter Bonivart. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

=cut

