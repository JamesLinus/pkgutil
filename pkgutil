#!/usr/bin/env perl -w

# pkgutil - manages packages on Sun Solaris systems
# Copyright (C) 2008-2009 Peter Bonivart

# $Id$

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
#
# The author, Peter Bonivart, can be contacted by email at bonivart@opencsw.org

use strict;
use Getopt::Long;
use Cwd;
Getopt::Long::Configure qw(no_ignore_case bundling);

# unbuffered output
$| = 1;

my $debug = 0;
my $pkgutilver = "1.9b3";
my $use_md5 = 0;
my $use_gpg = 0;
my $noncsw = 0;
my $pkgliststyle = 0;
my $maxpkglist = 250000;
my @mirror;
my $defaultmirror = ("http://ibiblio.org/pub/packages/solaris/opencsw/current");
my $workdir = "/var/opt/csw/pkgutil";
my $pkgdir;
my $admin;
my ($line,$tmp,$wget,$yes,$force,$nomod,$gzip,$name,$ver,$pkgname,$filename,$hash);
my ($size,$deps,$cat,$tmppkg,$tmppkg2,$trace);
my (@exclude,%config,%pkg,%commonpkg,%pkgmirror);

# show available packages in catalog
sub available {
  foreach my $common (sort keys %commonpkg) {
    my $pkgname = $commonpkg{$common};
    foreach my $vers (sort keys %{$pkg{$pkgname}}) {
      my($size) = (split /\s+/, $pkg{$pkgname}{$vers})[5];
      my $tmp = sprintf ("%-20s %-20s %-25s %9s\n",$common,$pkgname,$vers,format_byte($size));
      if (scalar(@ARGV) > 0) {
        foreach (@ARGV) {
          print $tmp if ("$pkgname-$vers" =~ /$_/i || "$common-$vers" =~ /$_/i);
        }
      } else {
         print $tmp;
      }
    }
  }
  myexit("","",0);
}

# check catalog
#   always - always update catalog
sub check_catalog {
  my($always) = @_;

  foreach my $url (@mirror) {
    my $filename = mangle_url($url);
    my $age = 0;
    $age = -M $filename if (-r $filename);
    print STDERR "Catalog $url age in days: $age\n" if $debug;
    fetch_catalog($url, $filename) if (($age > $config{catalog_update} && $config{catalog_update} != -1) || ! -e $filename || $always);
    gpg($filename) if $use_gpg;
    read_catalog($url, $filename); # Once per file
  }
}

# check if package is already installed and if so, which version
#   pkg  - package to check for
#   mode - 0 = return full string, 1 = return only rev part
sub check_pkg {
  my ($pkg,$mode) = @_;
  my ($tmp,$exit_code,$retvalue);

  $tmp = `/bin/pkgparam $pkg VERSION 2> /dev/null`;
  $exit_code = $?;
  chomp $tmp;
  if (! $exit_code) {
    if ($mode == 0) {
      $retvalue = $tmp;
    } else {
      ($retvalue) = ($tmp =~ /REV=(.+)$/);
    }
    print STDERR "$pkg installed, version $retvalue\n" if $debug;
  }
  if ($exit_code > 0) {
    $retvalue = "notinst";
    print STDERR "$pkg not installed\n" if $debug;
  }
  return $retvalue;
}

# compare current to available packages
#   mode - 0 = print full list, 1 = return list of old packages
#          2 = return full list of old packages, 3 = same as 0 but only diffs
#          4 = compare a single package (much faster, used with Puppet)
sub compare {
  my ($mode) = @_;
  my (@cswpkgs,@retlist);
  my ($pkg,$local_ver,$remote_ver,$tmp);

  print "package\t\t\t  installed\t\t    catalog\n" if ($mode == 0 || $mode == 3);
  if ($mode == 4) {
    $cswpkgs[0] = "a " . parse_catalog($ARGV[0],2) . " a";
    myexit("not in catalog","",1) if ($cswpkgs[0] eq "a not in catalog a");
  } else {
    if ($noncsw) {
      @cswpkgs = `/bin/pkginfo`;
    } else {
      @cswpkgs = `/bin/pkginfo | grep CSW`;
    }
  }
  foreach $pkg (@cswpkgs) {
    ($pkg) = ($pkg =~ /\s+?(\S+?)\s/);
    $local_ver = check_pkg($pkg,0);
    $remote_ver = parse_catalog($pkg,1);
    $remote_ver = "SAME" if ($local_ver eq $remote_ver);
    if ($mode == 1) {
      push(@retlist,$pkg) if ($remote_ver ne "SAME" && $remote_ver ne "not in catalog");
    } else {
      $tmp = sprintf ("%-25s %-25s %-25s\n",$pkg,$local_ver,$remote_ver);
      if ($mode == 2) {
        push(@retlist,$tmp) if ($remote_ver ne "SAME" && $remote_ver ne "not in catalog");
      } else {
        if (scalar(@ARGV) > 0 && $mode != 4) {
          foreach (@ARGV) {
            if ($pkg =~ /$_/i) {
              print $tmp unless ($mode == 3 && $remote_ver eq "SAME");
            }
          }
        } else {
          print $tmp unless ($mode == 3 && $remote_ver eq "SAME");
        }
      }
    }
  } 
  if ($mode == 1 || $mode == 2) {
    return @retlist;
  } else {
    myexit("","",0);
  }
}

# describe available packages
sub describe {
  my $desc_file = mangle_url($mirror[0]);
  $desc_file =~ s|/catalog\.|/descriptions\.|;

  check_catalog(1) unless (-r $desc_file);
  open(DESC,"<$desc_file");
  while (my $line = <DESC>) {
    chomp $line;
    if (scalar(@ARGV) > 0) {
      foreach (@ARGV) {
        print "$line\n" if ($line =~ /$_/i);
      }
    } else {
      print "$line\n";
    }
  }
  close DESC;
  myexit("","",0);
}

# check catalog
# email notifications when updates are available
#   email - address to send notications to
sub email {
  my ($email) = @_;
  my $file = "/tmp/pkgutil.$$.$^T";

  die "Mailx not found on system!\n" unless (-x "/bin/mailx");
  my @update_list = compare(2);
  if (scalar(@update_list) > 0) {
    open (FILE,">$file") or die "Can't open $file: $!\n";
    foreach (@update_list) {
      print FILE;
    }
    close FILE;
    chomp(my $host = `uname -n`);
    my $subject = "$host: CSW updates available";
    my @args = ("/bin/mailx -s \"$subject\" $email < $file");
    system (@args);
    unlink $file;
  }
  myexit("","",0);
}

# fetch catalog
#   url - url to download from
#   filename - filename to use for local catalog
sub fetch_catalog {
  my($url, $filename) = @_;
  my $wgetopts = "";
  my $status;

  $wgetopts .= " $config{wgetopts}" if $config{wgetopts};
  print "Fetching new catalog and descriptions ($url) if available...\n";
  myexit("Option -n selected, stopping here.","",0) if $nomod;

  my $desc_file = $filename;
  $desc_file =~ s|/catalog\.?|/descriptions\.|;
  if ($url =~ /^file:/) {
    my ($tmpcatsrc) = ($url =~ /^file:\/(.+)$/);
    $status = system("/bin/cp $tmpcatsrc/catalog $filename");
    die "\nFetching of catalog failed.\n" if $status;
    $status = system("/bin/cp $tmpcatsrc/descriptions $desc_file");
    die "\nFetching of descriptions failed.\n" if $status;
  } else {
    locate_wget() unless (-x $wget);	# if wget disappeared locate alt.
    $status = system("$wget $wgetopts -O $filename $url/catalog");
    die "\nFetching of catalog failed.\n" if $status;
    $status = system("$wget $wgetopts -O $desc_file $url/descriptions");
    die "\nFetching of descriptions failed.\n" if $status;
  }
  system("/bin/touch $filename") if (-w $filename);
}

# get wanted package and its dependencies
#   pkglist - packages to fetch
#   mode - 4 = stream silent
sub fetch_pkgs {
  my ($mode,@pkglist) = @_;
  my $wgetopts = "";
  my ($file,$status);
  my $fh = ($mode == 4 ? *STDERR : *STDOUT);

  if (scalar(@pkglist) > 1 && ! $yes) {
    print scalar(@pkglist)," packages to fetch. Do you want to continue? [Y,n] ";
    chomp (my $prompt = <STDIN>);
    myexit("","",0) if ($prompt =~ /^[nN]/);
  }
  $wgetopts .= " $config{wgetopts}" if $config{wgetopts};
  my $i = 1;
  foreach my $pkg (@pkglist) {
    $file = parse_catalog($pkg,3);
    if (-r "$pkgdir/$file" && -s _ != parse_catalog($pkg,5)) {	# broken/empty files may be present
      print $fh "Removing non-matching local file for $pkg.\n";
      unlink "$pkgdir/$file";
    }
    if (-r "$pkgdir/$file") {
      $i++;
      print $fh "A local copy of $pkg exists and is of matching size.\n";
    } else {
      print $fh "Fetching $pkg (" . $i++ . "/" . scalar(@pkglist) . ")...\n";
      locate_wget() unless (-x $wget);	# if wget disappeared locate alt.
      my $tried;
      foreach (@{$pkgmirror{$file}}) {
        $tried = 1;
        if ($_ =~ /^file:/) {
          my ($tmpcatsrc) = ($_ =~ /^file:\/(.+)$/);
          run_hooks("prefetch", "$tmpcatsrc/$file", $pkg);
          $status = system("/bin/cp $tmpcatsrc/$file $pkgdir/$file");
        } else {
          run_hooks("prefetch", "$_/$file", $pkg);

          ## testing curl as download method
          ##fetch_pkgs_curl("$_/$file","$pkgdir/$file");

          $status = system("$wget $wgetopts -O $pkgdir/$file $_/$file");
        }
        unless ($status) {
          run_hooks("postfetch", "$_/$file", $pkg);
          last;
        }
      }
      if ($status || ! $tried) {
        myexit("\nFetching of $_ failed. Try updating your catalog with pkgutil -U.","",1);
      }
    }
    md5($pkg,"$pkgdir/$file",$mode) if $use_md5;
  }
}

## global vars
##my ($progress,$last);

## experimental code for curl downloads
##sub fetch_pkgs_curl {
##  my ($url,$file) = @_;

##print "url: $url\n";
##print "file: $file\n";

## only if available - eval?
##  use WWW::Curl::Easy;

##  my $curl = new WWW::Curl::Easy;

##  # Setting the options
##  $curl->setopt(CURLOPT_NOPROGRESS, 1);
##  $curl->setopt(CURLOPT_NOPROGRESS, 0);
##  $curl->setopt(CURLOPT_PROGRESSFUNCTION, \&curl_progress_callback);
##  $curl->setopt(CURLOPT_HEADER, 0);
##  $curl->setopt(CURLOPT_URL, $url);
##  open(my $fp,">$file") or die "Can't open $file: $!\n";
##  $curl->setopt(CURLOPT_WRITEDATA, $fp);

##  # Starts the actual request
##  my $retcode = $curl->perform;

##print "progress: $progress\n";
##print "last: $last\n";

##  # Looking at the results...
##  if ($retcode == 0) {
##    print("Transfer went ok\n");
##    my $response_code = $curl->getinfo(CURLINFO_HTTP_CODE);
##    # judge result and next action based on $response_code
##    print("Received response: $response_code\n");
##  } else {
##    print("Error: " . $curl->strerror($retcode) . " ($retcode)\n");
##  }
##  close $file;
##exit;
##}

##sub curl_progress_callback {
##  my ($clientp,$dltotal,$dlnow,$ultotal,$ulnow) = @_;
##  $last = $dlnow;
##  $progress++;
##  return 0;
##}

# find files in package (-F)
sub find_file {
  my $contents = "/var/sadm/install/contents";

  foreach (@ARGV) {
    open (FILE,"<$contents") or die "Can't open $contents: $!\n";
    while(my $line = <FILE>) {
      chomp $line;
      my ($file,$pkg) = ($line =~ /^(.+?)\s.+\s(.+)$/);
      ($file) = ($file =~ /^(.+)=/) if ($file =~ /=/);
      print "$file\t$pkg\n" if ($file =~ /\Q$_\E/);
    }
    close FILE;
  }
  myexit("","",0);
}

# format size in bytes to more human friendly format with suffixes
#   size - size in bytes
sub format_byte {
  my ($size) = @_;
  my $suffix = "B";

  if ($size > 1024) {
    $size /= 1024;
    $suffix = "KB";
  }
  if ($size > 1024) {
    $size /= 1024;
    $suffix = "MB";
  }
  if ($size > 1024) {
    $size /= 1024;
    $suffix = "GB";
  }
  return sprintf ("%1.1f %s",$size,$suffix);
}

# check signature on catalog
sub gpg {
  my ($catalog) = @_;
  my $line;
  my $gpg_signed_catalog = 0;

  if (! -x "/opt/csw/bin/gpg") {
    myexit("GPG not found! Install CSWgnupg or disable use_gpg in pkgutil.conf.","",1);
  }
  open (CATALOG,"<$catalog") or die "Can't open $catalog: $!\n";
  while ($line = <CATALOG>) {
    $gpg_signed_catalog = 1 if ($line =~ /-BEGIN PGP SIGNED MESSAGE-/);
    last;
  }
  close CATALOG;
  print STDERR "GPG catalog: $gpg_signed_catalog\n" if $debug;
  if ($gpg_signed_catalog) {
    print "Checking catalog integrity with gpg.\n";
    rename($catalog, $catalog . ".asc") or die "Could not rename catalog!\n";
    my $status = system("/opt/csw/bin/gpg $catalog.asc");
    die "Catalog signature is not correct!\n" if $status;
    rename($catalog . ".asc", $catalog) or die "Could not rename catalog!\n";
    print STDERR "Status GPG: $status\n" if $debug;
  } else {
    myexit("Catalog $catalog is not signed! Check your mirror settings or disable use_gpg in pkgutil.conf.","",1);
  }
}

# init
#   conf - custom configuration
sub init {
  my ($conf) = @_;
  my @conf_file;
  if ($conf) {
    @conf_file = ($conf);
  } else {
    @conf_file = ("/opt/csw/etc/pkgutil.conf","/etc/opt/csw/pkgutil.conf");
  }
  %config = ("mirror"			=> [],
             "pkgaddopts"		=> "",
             "wgetopts"			=> "",
             "use_gpg"			=> "",
             "use_md5"			=> "",
             "pkgliststyle"		=> "",
             "maxpkglist"		=> "",
             "noncsw"			=> "",
             "stop_on_hook_soft_error"	=> "",
             "exclude_pattern"		=> "",
             "catalog_update"		=> "14");

  foreach (@conf_file) {
    if (-r $_) {	# if conf file found, parse it
      print STDERR "Conf file: $_\n" if $debug; 
      open (CONFIG,"<$_") or die "Can't open $_: $!\n";
      while (<CONFIG>) {
        chomp;	# remove newline
        s/#.*//;	# remove comments
        s/^\s+//;	# remove leading white
        s/\s+$//;	# remove trailing white
        next unless length;	# next if nothing left
        my ($var,$value) = split(/\s*=\s*/,$_,2);
        print STDERR "Found $var = $value\n" if $debug;
        my $r = ref($config{$var});
        if (! $r) {
         $config{$var} = $value;
        } elsif ($r eq 'ARRAY') {
          push(@{$config{$var}},$value);
        }

      }
      close CONFIG;
    }
  }

  if ($debug) {
    print "maxpkglist: $config{maxpkglist}\n";
    print "mirror: " . join("\t", @{$config{mirror}}) . "\n";
    print "noncsw: $config{noncsw}\n";
    print "pkgaddopts: $config{pkgaddopts}\n";
    print "pkgliststyle: $config{pkgliststyle}\n";
    print "use_gpg: $config{use_gpg}\n";
    print "use_md5: $config{use_md5}\n";
    print "wgetopts: $config{wgetopts}\n";
    print "stop_on_hook_soft_error: $config{stop_on_hook_soft_error}\n";
    print "exclude_pattern: $config{exclude_pattern}\n";
    print "catalog_update: $config{catalog_update}\n";
  }

  $pkgliststyle = $config{pkgliststyle} if $config{pkgliststyle};
  $maxpkglist = $config{maxpkglist} if $config{maxpkglist};
  $use_md5 = $use_gpg = $noncsw = 0;
  $use_md5 = 1 if ($config{use_md5} eq "true");
  $use_gpg = 1 if ($config{use_gpg} eq "true");
  $noncsw = 1 if ($config{noncsw} eq "true" || $config{noncsw} eq "yes");
}

# install local packages
#   pkglist - packages to install
sub inst_loc_pkgs {
  my @pkglist = @_;
  my $pkgadd = "/usr/sbin/pkgadd";
  my $pkgaddopts = "";
  my $pkgrm = "/usr/sbin/pkgrm";
  my $pkginfo = "/usr/bin/pkginfo";
  my $file;
  my $pkgtrace = "";

  $pkgaddopts .= " $config{pkgaddopts}" if $config{pkgaddopts};
  $pkgtrace = "-v" if $trace;

  foreach (@pkglist) {
    my $pkgforce = "";
    $pkgforce = "-a $admin -n" if ($yes && -r $admin);
    
    print "=> Installing $_\n";
    $file = $_;
    if ($_ =~ /\.gz$/) {		# not all packages are compressed
      my $status = locate_gzip();
      ($file) = ($file =~ /(.+)\.gz$/);
      if (! $status) {
        if ($yes) {
          `$gzip -c -f -d $_ > $file`;
        } else {
          `$gzip -c -d $_ > $file`;
        }
      } else {
        myexit("\nGzip not found, please install CSWgzip.","",1);
      }
    }

    # remove first if the package is already installed
    my $pkgname = `$pkginfo -d $file`;
    ($pkgname) = ($pkgname =~ /\s(.+?)\s/);
    my $tmp = check_pkg($pkgname,0);
    if ($tmp ne "notinst") {
      print "=> Removing currently installed $pkgname\n";
      system("$pkgrm $pkgforce $pkgtrace $pkgname");
    }

    # install
    system("$pkgadd $pkgforce $pkgtrace $pkgaddopts -d $file");
    if ($_ =~ /\.gz$/) {		# not all packages are compressed
      unlink "$file" or die "Can't delete $file: $!\n";
    }
  }
  myexit("","",0);
}

# install packages
#   batchmode - whether we're updating some of the packages or doing new
#               installs only (values: upgrade or install)
#   pkglist - packages to install
sub inst_pkgs {
  my $batchmode = shift;
  my @pkglist = @_;
  my $tmp = "";
  my $pkgadd = "/usr/sbin/pkgadd";
  my $pkgaddopts = "";
  my $pkgrm = "/usr/sbin/pkgrm";
  my $file;
  my $name;
  my $pkgtrace = "";
  my $per_package_hook = "install";

  $pkgaddopts .= " $config{pkgaddopts}" if $config{pkgaddopts};
  $pkgtrace = "-v" if $trace;

  run_hooks("prebatch$batchmode", @pkglist);

  # removing old version of all packages being upgraded
  foreach (reverse @pkglist) {
    my $pkgforce = "";
    $pkgforce = "-a $admin -n" if ($yes && -r $admin);
    my ($pkgname) = ($_ =~ /^(.+)-/);
    $tmp = check_pkg($pkgname,0);
    if ($tmp ne "notinst") {
      # a small sanity check
      die "Batch hook 'install' was run, but we've found a package being upgraded. Bailing out." if ($batchmode eq 'install');

      $per_package_hook = 'upgrade';
      run_hooks("pre$per_package_hook", $_);
      print "=> Removing old version of $pkgname\n";
      system("$pkgrm $pkgforce $pkgtrace $pkgname");
    }
  }

  # install all packages being upgraded/installed
  foreach (@pkglist) {
    my $pkgforce = "";
    $pkgforce = "-a $admin -n" if ($yes && -r $admin);
    $file = parse_catalog($_,3);
    $name = parse_catalog($_,2);
    print "=> Installing $_\n";
    if ($file =~ /\.gz$/) {		# not all packages are compressed
      my $status = locate_gzip();
      if (! $status) {
        if ($yes) {
          `$gzip -f -d $pkgdir/$file`;
        } else {
          `$gzip -d $pkgdir/$file`;
        }
      } else {
        myexit("\nGzip not found, please install CSWgzip.","",1);
      }
      ($file) = ($file =~ /(.+)\.gz$/);
    }

    # we may have already run preupgrade above. running upgrade _and_ install
    # is invalid
    run_hooks("pre$per_package_hook", $_) if ($per_package_hook eq 'install');

    # support response (pkgask) files
    $pkgaddopts .= " -r $workdir/pkgask/$name" if (-r "$workdir/pkgask/$name");
    print STDERR "pkgaddopts: $pkgaddopts\n" if $debug;
    
    system("$pkgadd $pkgforce $pkgtrace $pkgaddopts -d $pkgdir/$file $name`");
    unlink "$pkgdir/$file" or die "Can't delete $pkgdir/$file: $!\n";

    run_hooks("post$per_package_hook", $_);
    $per_package_hook = 'install'; # reset for next package in the list
  }
  run_hooks("postbatch$batchmode", @pkglist);
}

# install (-i) option
#   mode - 0 = install, 1 = download only, 2 = remove, 3 = stream,
#          4 = stream silent, 5 = extract
#   deps - option --nodeps set or not
sub install {
  my ($mode,$deps) = @_;
  my $retvalue;
  my (@tmppkglist,@revpkglist,@newpkglist,@instpkglist,@updpkglist,@curpkglist,@dlpkglist);
  my $fh = ($mode == 4 ? *STDERR : *STDOUT);
  my(%pkgvers,@pkglist,@excludelist); # @pkglist is specifically in the correct order.

  print $fh "Parsing catalog, may take a while...\n";
  foreach my $tmppkg (@ARGV) {
    my $tmp = parse_catalog($tmppkg,2);
    my $vers = parse_catalog($tmppkg,1);
    if ($tmp ne 'not in catalog' && ($tmp =~ /^CSW/ || $noncsw)) {
      push(@pkglist,$tmp);
      $pkgvers{$tmp} = $vers;
    } else {
      myexit("Package $tmppkg not in catalog...exiting.","",1);
    }
  }

  unless ($deps) {	# skip adding dependencies? (option --nodeps)
    my %finished;
    foreach my $tmppkg2 (@pkglist) {
      # N.B. This array grows and we keep looping until we've satisfied all
      # of the dependencies.
      print STDERR "Loop #",scalar(@pkglist)," (limit $maxpkglist)\n" if $debug;
      die "Loop protection limit ($maxpkglist) hit. There's probably a cyclic dependency\nin the catalog.\n" if (scalar(@pkglist) > $maxpkglist);
      my @tmpdeps;

      ## Skip stuff already checked, partly to avoid loops but also to gain
      ## speed if possible
      ## Uncomment one of the below if you want to try it

      ## 1. Suggestion from Joe Baro, avoids loops, skips lots of iterations
      ##    but reorders install order
      ##next if $finished{$tmppkg2};
      ##$finished{$tmppkg2} = 1;

      ## 2. My "deduplicate at every hit" suggestion, reduces iterations but
      ##    still reorders list
      ##if ($finished{$tmppkg2}) {
      ##  my @tmppkglist = @pkglist;
      ##  my $tmp;
      ##  undef @pkglist;
      ##  while (scalar(@tmppkglist)) {
      ##    $tmp = shift(@tmppkglist);
      ##    if ($tmp eq $tmppkg2) {
      ##      push(@pkglist,@tmppkglist);
      ##      last;
      ##    } else {
      ##      push(@pkglist,$tmp);
      ##    }
      ##  }
      ##}
      ##$finished{$tmppkg2} = 1;

      ## end of skip stuff tests

      if ($tmppkg2 ne "CSWcommon") {
        $retvalue = parse_catalog($tmppkg2,6);
        if ($retvalue eq "not in catalog") {
          system("pkginfo -q $tmppkg2");
          next if $? == 0;	# already installed... forgive its absence from the catalog
          myexit("Package $tmppkg2 not in catalog...exiting.","",1);
        } else {
          @tmpdeps = split(/\|/,$retvalue);
          print STDERR "depmap: $tmppkg2 -> ", $retvalue, "\n" if $debug;
        }
      } else {
        next;
      }
      if ($tmpdeps[0] ne "none") {
        foreach my $dep (@tmpdeps) {
          # there is no support for dependencies against a particular version, e.g. CSWzope-3.3.1, just CSWzope
          if (! exists $pkgvers{$dep}) {
            $pkgvers{$dep} = parse_catalog($dep,1);
          }
          push(@pkglist,$dep);	# append to list, does not include deduplication
        }
      }
      next;
    }
  }
  print STDERR "pkglist ", join(",", @pkglist), "\n" if $debug;

  # clean list from excludes. Delete from the %pkgvers hash
  foreach my $pkg (@exclude) {
    if (exists $pkgvers{$pkg}) {
      delete $pkgvers{$pkg};
      push(@excludelist,$pkg);
    }
  }

  # now reverse and deduplicate @pkglist. Need the last instance of each
  # package if reading @pkglist forwards
  my %deduped;
  for my $pkg (reverse @pkglist) {
    next unless $pkgvers{$pkg}; # not if excluded
    unless (exists $deduped{$pkg}) {
      push(@revpkglist,$pkg);
      $deduped{$pkg} = 1;
    }
  }

  # clean list from exclude patterns in pkgutil.conf
  foreach my $pattern (split(/\s+?/,$config{exclude_pattern})) {
    my @tmppkglist = grep(!/$pattern/,@revpkglist);
    push(@excludelist,grep(/$pattern/,@revpkglist));
    @revpkglist = @tmppkglist;
  }

  if ($mode == 2) {		# if -r used
    if (scalar(@revpkglist) > 0) {
      my @rmpkgs = ();
      foreach my $p (@revpkglist) {
	push(@rmpkgs, "$p-" . $pkgvers{$p});
      }
      rem_pkgs(reverse @rmpkgs);
    }
  }
  print STDERR "revpkglist ", join(",", @revpkglist), "\n" if $debug;

  ## temporary for testing loop/speed suggestions
  ##print "revpkglist: " . scalar(@revpkglist) . "\n", join(",", @revpkglist), "\n";
  ##print "Loop #",scalar(@pkglist)," (limit $maxpkglist)\n";
  ## temporary for testing loop/speed suggestions

  # incompatible packages (I-dependencies)
  my @ideppkglist;
  foreach (@revpkglist) {
    my $retvalue = parse_catalog($_,8);
    push(@ideppkglist,split(/\|/,$retvalue)) if ($retvalue ne "none");
  }
  # clean the list from packages not installed
  my @ideppkglist2;
  foreach (@ideppkglist) {
    # check if pkg is present first
    push(@ideppkglist2,$_) if (check_pkg($_,0) ne "notinst");
  }
  @ideppkglist = @ideppkglist2;
  undef @ideppkglist2;

  # which packages do we really need to download?
  if ($mode == 0 || $mode == 2) {
    foreach (@revpkglist) {
      my $old = check_pkg($_,0);
      my $new = $pkgvers{$_};
      if ($old eq "notinst") {	# new package needed
        push(@newpkglist,"$_-$new");
      } else {			# package already installed
        my $cmpval = verscmp($new,$old);
        if ($cmpval == 1 || ($cmpval != 0 && $force)) {	# older or --force
          push(@updpkglist,"$_-$new");	# updated package needed
        } else {
          push(@curpkglist,"$_-$old");	# package is current
        }
      }
    }
  } else {	# if -s or --extract then just copy revpkglist to newpkglist
    foreach (@revpkglist) {
      push(@newpkglist,"$_-$pkgvers{$_}");
    }
  }

  my $pkgsep = ($pkgliststyle ? "\n\t" : " ");

  # only present incompatible packages when doing install/upgrade
  if ($mode == 0) {
    if (scalar(@ideppkglist) > 0) {
      print "Remove INCOMPATIBLE packages:$pkgsep", join("$pkgsep", sort @ideppkglist), "\n";
    }
  }

  # different text for install/upgrade vs. the rest
  if (scalar(@newpkglist) > 0) {
    print $fh ($mode == 0) ? "Install NEW packages" : "Package list";
    print $fh ":$pkgsep", join("$pkgsep", sort @newpkglist), "\n";
  }

  # only present updated and current packages when doing install/upgrade
  if ($mode == 0) {
    if (scalar(@updpkglist) > 0) {
      print "Install UPDATED packages:$pkgsep", join("$pkgsep", sort @updpkglist), "\n";
    }

    if (scalar(@curpkglist) > 0) {
      print "CURRENT packages:$pkgsep", join("$pkgsep", sort @curpkglist), "\n";
    }
  }

  # different text for install/upgrade vs. the rest
  if (scalar(@excludelist) > 0) {
    print $fh "EXCLUDED packages:$pkgsep", join("$pkgsep", sort @excludelist), "\n";
  }

  # what packages do we need to fetch?
  # make sure they are in correct order
  foreach my $i (@revpkglist) {
    my $hit = 0;
    foreach (@curpkglist) {
      my ($j) = ($_ =~ /^(.+)-/);
      if ($i eq $j) {
        $hit = 1;
        print STDERR "i: $i j: $j hit: $hit\n" if $debug;
        last;
      }
      print STDERR "i: $i j: $j hit: $hit\n" if $debug;
    }
    my $tmp = "$i-$pkgvers{$i}";
    push(@dlpkglist,$tmp) unless $hit;
  }
  print STDERR "dlpkglist ", join(",", @dlpkglist), "\n" if $debug;

  # print info before exiting if there's nothing to do
  myexit("\nNothing to do.","",0) if (scalar(@dlpkglist) == 0);

  # print size of download
  if (scalar(@dlpkglist) > 0) {
    foreach (@dlpkglist) {
      $size += parse_catalog($_,5);
    }
    print $fh "Total size: " . format_byte($size) . "\n";
  }

  myexit("Option -n selected, stopping here.","",0) if $nomod;

  if (scalar(@dlpkglist) > 0) {
    fetch_pkgs($mode,@dlpkglist);
  }

  extract_pkg(@dlpkglist) if ($mode == 5);	# --extract

  return @revpkglist if ($mode == 3 || $mode == 4);	# if -s used

  # remove incompatible packages
  if (scalar(@ideppkglist) > 0 && $mode == 0) {
    my $pkgrm = "/usr/sbin/pkgrm";
    my $pkgtrace = "";
    my $pkgforce = "";
    $pkgforce = "-a $admin -n" if ($yes && -r $admin);
    if (! $yes) {
      print scalar(@ideppkglist)," incompatible package" . (scalar(@ideppkglist) > 1 ? "s" : "") . " to remove. Do you want to continue? [Y,n] ";
      chomp (my $prompt = <STDIN>);
      myexit("","",0) if ($prompt =~ /^[nN]/);
    }
    foreach (@ideppkglist) {
      print "=> Removing incompatible package $_\n";
      system("$pkgrm $pkgforce $pkgtrace $_");
    }
  }

  if ($mode == 0) {		# if -d not used, install
    if (scalar(@dlpkglist) > 0) {
      inst_pkgs(scalar(@updpkglist) ? 'upgrade' : 'install', @dlpkglist);
    }
  }
  myexit("","",0);
}

# list files in package
sub list_file {
  my $contents = "/var/sadm/install/contents";

  foreach (@ARGV) {
    if (-r $_ && -f _) {	# argument is a package file
      if ($_ =~ /\.pkg$/) {
        my (@tmp) = `/usr/sbin/pkgchk -l -d $_ all`;
        foreach (@tmp) {
          next unless ($_ =~ /^Pathname:\s\//);
          my ($file) = ($_ =~ /^Pathname:\s(.+?)\s/);
          ($file) = ($file =~ /^(.+)=/) if ($file =~ /=/);
          print "$file\n";
        }
      } else {
        print "Package file name [$_] must end in .pkg\n";
        next;
      }
    } else {	# argument is a package name
      my $tmp;
      if ($_ =~ /^[A-Z]/) {
        $tmp = $_;
      } else {
        $tmp = parse_catalog($_,2);
      }
      open (FILE,"<$contents") or die "Can't open $contents: $!\n";
      while(my $line = <FILE>) {
        chomp $line;
        my ($file,$pkg) = ($line =~ /^(.+?)\s.+\s(.+)$/);
        ($file) = ($file =~ /^(.+)=/) if ($file =~ /=/);
        print "$file\n" if ($pkg eq $tmp);
      }
      close FILE;
    }
  }
  myexit("","",0);
}

# find gzip
sub locate_gzip {
  my @locations = ("/opt/csw/bin","/bin","/usr/local/bin");

  foreach (@locations) {
    if (-x "$_/gzip") {
      $gzip = "$_/gzip";
      last;
    }
  } 
  print STDERR "gzip: $gzip\n" if $debug;
  return 1 if (! $gzip);
}

# find wget
sub locate_wget {
  my @locations = ("/opt/csw/bin","/usr/sfw/bin","/usr/local/bin");
  my $libexec = "/opt/csw/libexec/pkgutil";

  foreach (@locations) {
    if (-x "$_/wget") {
      $wget = "$_/wget";
      last;
    }
  } 
  if (! $wget) {
    $wget = "$libexec/wget" if (-x "$libexec/wget");
  }
  print STDERR "wget: $wget\n" if $debug;
  return 1 if (! $wget);
}

# make a filename from the URL - /es to _es.
#   url - url to mangle
sub mangle_url {
  my($url) = @_;

  (my $mangled = $url) =~ s?\w+://??;
  $mangled =~ s?/?_?g;
  my $filename = "$workdir/catalog.$mangled";
  return $filename;
}

# check md5 on downloaded files
#   mode - 4 = stream silent
sub md5 {
  my ($pkg,$file,$mode) = @_;
  my $md5;
  my $fh = ($mode == 4 ? *STDERR : *STDOUT);

  eval { require Digest::MD5; };
  if ($@) {
    if (-x "/opt/csw/bin/gmd5sum") {
      die "Can't open $file: $!\n" unless (-r $file);
      $md5 = `/opt/csw/bin/gmd5sum $file`;
      ($md5) = ($md5 =~ /^(.*\w) /);
    } else {
      myexit("\nMD5 support not available! Install CSWtextutils to get MD5\nsupport. Another alternative is to install CSWperl and use\nthat for pkgutil. Do that by having /opt/csw/bin before\n/usr/bin in your path.","",1);
    }
  } else {
    open (FILE,"<$file") or die "Can't open $file: $!\n";
    binmode (FILE);
    $md5 = Digest::MD5->new->addfile(*FILE)->hexdigest;
    close FILE;
  }
  my $md5cat = parse_catalog($pkg,4);
  print STDERR "$pkg md5 file: $md5\n$pkg md5 cat:  $md5cat\n" if $debug;
  die "MD5 for $pkg doesn't match catalog!\n" if ($md5 ne $md5cat);
  print $fh "MD5 for $pkg matched.\n";
}

# do cleanup and exit with return code
#   msg - message to stderr
#   err - error ($!)
#   rc - return code when exiting
sub myexit {
  my ($msg,$err,$rc) = @_;

  my $text = ($msg && $err) ? "$msg: $err" : "$msg";
  $rc = 0 unless $rc;
  unlink $admin if ($admin && -r $admin);
  print STDERR "$text\n" if $text;
  exit $rc;
}

# parse catalog
#   pkg  - package to look for, can be both common name and true name
#   mode - what we want to return, field number from catalog
sub parse_catalog {
  my ($pkg,$mode) = @_;
  my ($retvalue, $name);

  print STDERR "Parsing catalog...looking for: $pkg (mode $mode)\n" if $debug;

  # do we have an embedded version?
  my @p = split /-/, $pkg;
  my $vers = pop @p;
  my $tryname = join('-', @p);

  # first check the whole name without stripping off a "version"
  # e.g. CSWdovecot-devel:
  if ($pkg{$pkg}) {
    # SysV, no version (e.g. CSWdovecot-devel)
    $name = $pkg;
    undef $vers;
  } elsif ($commonpkg{$pkg} && $pkg{$commonpkg{$pkg}}) {
    # Common (e.g. dovecot_devel)
    $name = $commonpkg{$pkg};
    undef $vers;
  } elsif ($pkg{$tryname}) {
    # SysV, version (e.g. CSWdovecot-devel-1.0.13,REV=2008.03.16)
    $name = $tryname;
  } elsif ($commonpkg{$tryname} && $pkg{$commonpkg{$tryname}}) {
    # Common (e.g. dovecot_devel-1.0.13,REV=2008.03.16)
    $name = $commonpkg{$tryname};
  }

  if ($name) {
    # have we a version match?
    if ($vers && exists $pkg{$name}{$vers}) {
      my @tmpcatline = split(/ /,$pkg{$name}{$vers});
      my $fieldsincatalog = scalar(@tmpcatline);
      if ($mode == 8 && $fieldsincatalog < 9) {
        $retvalue = "none";
      } else {
        $retvalue = (split(/ /,$pkg{$name}{$vers}))[$mode];
      }
    } elsif (! $vers) {
      # we may have multiple versions in the catalog, take the highest
      # note this won't work unless at least one has a REV in it
      my $highest = (sort { verscmp($b, $a) } keys %{$pkg{$name}})[0];
      my @tmpcatline = split(/ /,$pkg{$name}{$highest});
      my $fieldsincatalog = scalar(@tmpcatline);
      if ($mode == 8 && $fieldsincatalog < 9) {
        $retvalue = "none";
      } else {
        $retvalue = (split(/ /,$pkg{$name}{$highest}))[$mode];
      }
    } else {
      $retvalue = "not in catalog" if (! $retvalue);
    }
  } else {
    $retvalue = "not in catalog" if (! $retvalue);
  }
  print STDERR "Return value: $retvalue\n" if $debug;
  return $retvalue;
}

# parse command line
sub parse_cl {
  my ($opt_install,$opt_upgrade,$opt_remove,$opt_download,$opt_avail,
      $opt_compare,$opt_upd_cat,$opt_email,@opt_temp,$opt_help,$opt_version,
      $opt_syscheck,$opt_stream,$opt_target,$opt_output,$opt_workdir,
      $opt_config,$opt_compare_diffonly,$opt_listfile,$opt_findfile,
      $opt_describe,$opt_extract,$opt_nodeps,$opt_single);

  usage() if (@ARGV == 0);

  # this call gives hooks a chance to look at the unaltered argument list.
  print STDERR "preargproc: " . join(' ',@ARGV) . "\n" if $debug;
  run_hooks("preargproc", @ARGV);

  GetOptions("i|install"	=> \$opt_install,
             "u|upgrade"	=> \$opt_upgrade,
             "r|remove"		=> \$opt_remove,
             "d|download"	=> \$opt_download,
             "a|available"	=> \$opt_avail,
             "describe"		=> \$opt_describe,
             "c|compare"	=> \$opt_compare,
             "C"		=> \$opt_compare_diffonly,
             "config=s"		=> \$opt_config,
             "U|catalog"	=> \$opt_upd_cat,
             "e|email=s"	=> \$opt_email,
             "t|temp=s"		=> \@opt_temp,
             "y|yes"		=> \$yes,
             "f|force"		=> \$force,
             "s|stream"		=> \$opt_stream,
             "T|target=s"	=> \$opt_target,
             "o|output=s"	=> \$opt_output,
             "x|exclude=s"	=> \@exclude,
             "W|workdir=s"	=> \$opt_workdir,
             "n|nomod"		=> \$nomod,
             "D|debug"		=> \$debug,
             "trace"		=> \$trace,
             "h|help"		=> \$opt_help,
             "v|version"	=> \$opt_version,
             "L|listfile"	=> \$opt_listfile,
             "F|findfile"	=> \$opt_findfile,
             "extract"		=> \$opt_extract,
             "single"		=> \$opt_single,
             "N|nodeps"		=> \$opt_nodeps,
             "V|syscheck"	=> \$opt_syscheck) || usage();

  # simple options
  usage() if $opt_help;
  pkgutilver(0) if $opt_version;
  pkgutilver(1) if $opt_syscheck;
  find_file() if $opt_findfile;

  # installing local packages if all args are package files
  if ($opt_install || $opt_upgrade) {
    my $notalocpkg = 0;
    foreach (@ARGV) {
      $notalocpkg = 1 unless (-r $_ && -s _ && $_ =~ /\.pkg(\.gz)?$/);
      print STDERR "$_ : $notalocpkg\n" if $debug;
    }
    unless ($notalocpkg) {
      print "Installing your local packages...\n";
      inst_loc_pkgs(@ARGV);
    }
  }

  init($opt_config) if $opt_config;
  locate_wget();
  locate_gzip();

  if ($opt_workdir) {	# set/create optional working dir
    $workdir = $opt_workdir;
    print STDERR "new workdir: $workdir\n" if $debug;
  } elsif ($>) {	# if -W not used and non-root, use pwd
    $workdir = getcwd();
    print STDERR "username: " . getpwuid($>) . "\n" if $debug;
    print "You're not root and didn't set -W, using current dir.\n";
  }
  $pkgdir = "$workdir/packages";

  # create runtime copy of admin to make sure we have one
  # available even during upgrade of pkgutil itself
  $admin = "$workdir/admin";
  $admin = "/var/opt/csw/pkgutil/admin" unless (-r $admin);
  open (ADMSRC,"<$admin") or die "Can't open $admin: $!\n";
  if (-r "$workdir/admin.run") {
    my @pslist = `/bin/ps -ef`;
    my $pkgutilinst = 0;
    foreach (@pslist) {
      $pkgutilinst++ if (/\bperl\s.*pkgutil\b/);
    }
    if ($pkgutilinst > 1) {
      die "Another instance of pkgutil is already running!\n";
    } else {
      unlink "$workdir/admin.run" if (-r "$workdir/admin.run");
      print "Stale lock file ($workdir/admin.run) removed\n";
    } 
  }
  open (ADMCPY,">$workdir/admin.run") or die "Can't open $workdir/admin.run: $!\n";
  while (<ADMSRC>) {
    print ADMCPY;
  }
  close ADMSRC;
  close ADMCPY;
  $admin = "$workdir/admin.run";

  my $status = system("/bin/mkdir -p $pkgdir");
  die "Could not create $pkgdir: $!\n" if $status;

  # Get mirrors together
  @mirror = @{$config{mirror}};
  $mirror[0] = $defaultmirror unless @mirror; # if no mirrors configured
  # Prepend temp mirrors so they are selected first
  unshift(@mirror,@opt_temp) if @opt_temp;

  my @supp_arch = qw(sparc i386);
  my @supp_rel = qw(5.8 5.9 5.10 5.11);
  my ($ok_arch,$ok_rel) = (0,0);
  my ($loc_arch,$loc_rel);

  if ($opt_target && $opt_download) {
    if ($opt_target =~ /.:./) {
      ($loc_arch,$loc_rel) = split(/:/,$opt_target);
    } else {
      myexit("$opt_target is not a correct arch:rel combo.","",1);
    }
  } else {
    chomp($loc_arch = `uname -p`);	# arch type sparc|i386
    chomp($loc_rel = `uname -r`);	# os version, e.g. 5.10
  }
  print STDERR "arch: $loc_arch\nos rel: $loc_rel\n" if $debug;

  foreach (@supp_arch) {
    if ($loc_arch eq $_) {
      $ok_arch = 1;
      last;
    }
  }
  foreach (@supp_rel) {
    if ($loc_rel eq $_) {
      $ok_rel = 1;
      last;
    }
  }
  print "Architecture $loc_arch not supported.\n" unless $ok_arch;
  print "OS release $loc_rel not supported.\n" unless $ok_rel;
  myexit("","",1) if (($ok_arch + $ok_rel) < 2);

  foreach (my $i=0; $i < scalar(@mirror); $i++) {
    ($mirror[$i]) = ($mirror[$i] =~ q!^(.+\w)!);
    $mirror[$i] .= "/" . $loc_arch . "/" . $loc_rel;
  }

  print STDERR "primary mirror: $mirror[0]\n" if $debug;
  if ($opt_upd_cat || @opt_temp) {
    check_catalog(1);	# Reread everything
  } else {
    check_catalog();
  }

  # running the hook now should pass only things that remain in ARGV,
  # which should be a list of package names.
  my @norm_argv;
  foreach (@ARGV) {
    push(@norm_argv,parse_catalog($_,2));
  }
  print STDERR "postargproc: " . join(' ',@norm_argv) . "\n" if $debug;
  run_hooks("postargproc", @norm_argv);

  # complex options
  list_file() if $opt_listfile;
  # download and stream if both -d and -s selected
  stream($loc_arch,$loc_rel,$opt_output) if ($opt_stream && $opt_download);
  email($opt_email) if $opt_email;
  available() if $opt_avail;
  describe() if $opt_describe;
  compare(3) if $opt_compare_diffonly;
  compare(4) if ($opt_compare && $opt_single);
  compare(0) if $opt_compare;
  # download and extract if both -d and --extract selected
  install(5,$opt_nodeps) if ($opt_extract && $opt_download);
  install(0,$opt_nodeps) if $opt_install;
  install(2,$opt_nodeps) if $opt_remove;	# remove instead of install
  install(1,$opt_nodeps) if $opt_download;	# download only

  # upgrade is a special case of install
  if ($opt_upgrade) {
    if (@ARGV == 0 || $ARGV[0] eq "all" || $ARGV[0] eq "ALL") {
      # need to manipulate ARGV to match installed CSW packages
      # that need upgrading (use -c mode 1)
      print "Looking for packages that can be upgraded...\n";
      my @cswpkgs = compare(1);
      my $i = 0;
      foreach (@cswpkgs) {
        $ARGV[$i++] = $_;
      }
    }
    install(0);
  }

  # arguments but no options
  print "You need to select a valid option!\n" if (! $opt_upd_cat);
}

# show version info
#   mode - 0 = print only version, 1 = system check
sub pkgutilver {
  my ($mode) = @_;
  my $flag = 0;
  chomp(my $solver = `uname -r`);
  chomp(my $solarch = `uname -p`);
  my ($pkgpatch,$pkgpatchinst);

  if ($mode) {
    print "- System -\n";
    print "Pkgutil\t\t$pkgutilver\n";
    print "Arch\t\t$solarch\n";
    print "Solaris\t\t$solver\n";
    $pkgpatch = ($solarch eq "sparc") ? "110934" : "110935" if ("$solver" eq "5.8");
    $pkgpatch = ($solarch eq "sparc") ? "113713" : "114568" if ("$solver" eq "5.9");
    $pkgpatch = ($solarch eq "sparc") ? "119317" : "119318" if ("$solver" eq "5.10");
    if ($solver ne "5.11") {
      chomp($pkgpatchinst = `showrev -p | grep $pkgpatch | cut -d' ' -f2 | grep $pkgpatch | sort | tail -1`);
      $pkgpatchinst = ($pkgpatchinst) ? "$pkgpatchinst installed" : "not found";
    } else {
      $pkgpatch = $pkgpatchinst = "na";
    }
    print "Pkg patch\t$pkgpatch ($pkgpatchinst)\n";
    if (-x "/opt/csw/bin/gpg") {
      print "GPG binary\t/opt/csw/bin/gpg\n";
    } else {
      print "GPG binary\tnot found (suggestion: install CSWgnupg)\n";
    }
    my $status = locate_gzip(); 
    print "Gzip binary\t" . (($status) ? "not found (suggestion: install CSWgzip)" : $gzip) . "\n";
    if (-x "/bin/mailx") {
      print "Mailx binary\t/bin/mailx\n";
    } else {
      print "Mailx binary\tnot found (option --email not available)\n";
    }
    if (-x "/opt/csw/bin/gmd5sum") {
      print "MD5 binary\t/opt/csw/bin/gmd5sum\n";
    } else {
      print "MD5 binary\tnot found";
      print " (suggestion: install CSWtextutils)" unless $flag;
      print "\n";
      $flag = 0;
    }
    eval { require Digest::MD5; };
    if ($@) {
      print "MD5 module\tnot found\n";
    } else {
      print "MD5 module\t",Digest::MD5->VERSION," (primary choice for MD5)\n";
      $flag = 1;
    }
    print "Perl\t\t$]\n";
    print "Perl binary\t" . `which perl`;
    $status = locate_wget(); 
    print "Wget binary\t" . (($status) ? "not found (suggestion: install CSWwget)" : $wget) . "\n";
    print "PATH\t\t$ENV{PATH}\n";
    print "\n- Configuration -\n";
    print "catalog_update\t" . (($config{catalog_update}) ? $config{catalog_update} : "not set") . " (default: 14)\n";
    print "exclude_pattern\t" . (($config{exclude_pattern}) ? $config{exclude_pattern} : "not set") . " (default: none)\n";
    print "maxpkglist\t" . (($config{maxpkglist}) ? $config{maxpkglist} : "not set") . " (default: 25000)\n";
    print "mirror\t\t" . ((scalar(@{$config{mirror}})) ? join("\n\t\t", @{$config{mirror}}) : "not set") . "\n\t\t(default: $defaultmirror)\n";
    print "noncsw\t\t" . (($config{noncsw}) ? $config{noncsw} : "not set") . " (default: false)\n";
    print "pkgaddopts\t" . (($config{pkgaddopts}) ? $config{pkgaddopts} : "not set") . " (default: none)\n";
    print "pkgliststyle\t" . (($config{pkgliststyle}) ? $config{pkgliststyle} : "not set") . " (default: 0)\n";
    print "stop_on_hook_soft_error\t\t" . (($config{stop_on_hook_soft_error}) ? $config{stop_on_hook_soft_error} : "not set") . " (default: false)\n";
    print "use_gpg\t\t" . (($config{use_gpg}) ? $config{use_gpg} : "not set") . " (default: false)\n";
    print "use_md5\t\t" . (($config{use_md5}) ? $config{use_md5} : "not set") . " (default: false)\n";
    print "wgetopts\t" . (($config{wgetopts}) ? $config{wgetopts} : "not set") . " (default: none)\n";
  } else {
    print "$pkgutilver\n";
  }
  myexit("","",0);
}

# read catalog into hash
#   catalog - catalog to read
#   filename - filename to use
sub read_catalog {
  my($catalog, $filename) = @_;
  my @llst;

  open (CATALOG,"<$filename") or die "Can't open $filename: $!\n";
  while (my $line = <CATALOG>) {
    chomp $line;
    if ($line =~ /^\w/) {
      @llst = split(/ /,$line);
      if ($llst[0] && $llst[1] && $llst[2] && $llst[3] && $llst[4] && $llst[5] && $llst[6] && $llst[7]) {
        $pkg{$llst[2]}{$llst[1]} = $line;
        $commonpkg{$llst[0]} = $llst[2];
        push(@{$pkgmirror{$llst[3]}},$catalog);
      }
    }
  }
  close CATALOG;
}

# remove packages
#   pkglist - packages to remove
sub rem_pkgs {
  my @pkgs = @_;
  my $retval = "";
  my $pkgrm = "/usr/sbin/pkgrm";
  my $pkgforce = "";
  my $pkgtrace = "";
  my ($pkg,$i,$j,$k,$l,$depinuse,$skip);
  my (@cswpkgs,@deptmp,@rempkgs);

  $pkgforce = "-a $admin -n" if $yes;
  $pkgtrace = "-v" if $trace;
  print "Looking at installed CSW packages...\n";
  my @cswpkgstmp = `/bin/pkginfo | grep CSW`;
  foreach $pkg (@cswpkgstmp) {
    ($pkg) = ($pkg =~ /\s+?(\w+?)\s/);
    $skip = 0;
    foreach (@pkgs) {
      $skip = 1 if ($_ eq $pkg);
    }
    push(@cswpkgs,$pkg) unless $skip;
  }
  print "Examining dependencies for:\n";
  foreach my $userpkg (@pkgs) {
    $i = (split(/\-/, $userpkg))[0];
    print "  $i";
    $depinuse = 0;
    foreach $j (@cswpkgs) {
      $retval = parse_catalog($j,6);
      if ($retval ne "none" && $i ne $j) { 
        (@deptmp) = split(/\|/,$retval);
        foreach $k (@deptmp) {
          if ($k eq $i) {
            print STDERR "\n$i is in use by $j\n" if $debug;
            $depinuse = 1;
            last;
          }
        }
      }
      $depinuse ? last : next;
    }
    push(@rempkgs,$userpkg) unless $depinuse;
    $depinuse ? print " (in use)\n" : print " (remove)\n";
  }
  if (scalar(@rempkgs) > 1 && ! $yes) {
    print scalar(@rempkgs)," packages to remove. Do you want to continue? [Y,n] ";
    chomp (my $prompt = <STDIN>);
    myexit("","",0) if ($prompt =~ /^[nN]/);
  }
  if (scalar(@rempkgs) > 0) {
    run_hooks('prebatchremove', @rempkgs);

    foreach (@rempkgs) {
      my ($p, $v) = split(/\-/, $_);
      $retval = check_pkg($p,0);
      if ($retval ne "notinst") {
        myexit("Option -n selected, stopping here.","",0) if $nomod;
        print "=> Removing $p\n";
	run_hooks('preremove', ($_));
        system("$pkgrm $pkgforce $pkgtrace $p`");
	run_hooks('postremove', ($_));
      }
    }

    run_hooks('postbatchremove', @rempkgs);
  } else {
    print "Nothing to remove.\n";
  }
  myexit("","",0);
}

# run hooks
sub run_hooks {
  my $hook_name = shift;
  my @hook_args = @_;

  my $hook_dir = "/etc/opt/csw/pkg-hooks/$hook_name.d";
  my ($hook,$hookfile,$oldwd,$status,$code);
  my @hooks_to_run;
  my @valid_hooks = ('prebatchinstall',
                     'prebatchupgrade',
                     'prebatchremove',
                     'preinstall',
                     'preupgrade',
                     'preremove',
                     'postbatchinstall',
                     'postbatchupgrade',
                     'postbatchremove',
                     'postinstall',
                     'postupgrade',
                     'postremove',
		     'prefetch',
		     'postfetch',
		     'preargproc',
		     'postargproc');

  die "Invalid hook: $hook_name" unless (grep(/$hook_name/, @valid_hooks));

  if (! -d $hook_dir) {
    print STDERR "No $hook_name hook scripts.\n" if $debug;
  } else {
    $oldwd = getcwd();
    chdir($hook_dir) or die "Could not cd to $hook_dir";

    @hooks_to_run = glob("*");

    print "Executing $hook_name hook scripts.\n" if scalar(@hooks_to_run) and $debug;

    foreach my $hookfile (sort { $a cmp $b } (@hooks_to_run)) {
      $hook = "$hook_dir/$hookfile";
      if (-x $hook) {
        print STDERR "Running $hook.\n" if $debug;

	# @hook_args is (in most cases) a list of
	# CSWfoo-1.2.3,REV=YYYY.mm.dd affected packages, but in other
	# cases, it might be single or multiple URL's of packages
	# being pulled down, etc
        system("$hook " . join(' ', @hook_args));
        $status = $?;
        $code = $status >> 8;

        print STDERR "Script $hook_name.d/$hookfile returned code: $code\n" if $debug;

        # this allows a hook to stop execution of any further
        # package actions.
        if ($code == 1) {
          myexit("Hook $hook_name.d/$hookfile returned with code 1","dying",1);
        } elsif ($code == 2 && $config{'stop_on_hook_soft_error'} eq 'true') {
          myexit("Hook $hook_name.d/$hookfile returned with code 2","respecting configuration option stop_on_hook_soft_error",1);
        } elsif ($code > 2) {
          print STDERR "Hook $hook_name.d/$hookfile returned undefined code $code.\nContinuing anyway...\n";
        }
      }
    }

    chdir($oldwd);
  }
}

# build package streams
#   target - arch and os release
#   output - file name for package stream
sub stream {
  my ($arch,$rel,$output) = @_;
  my ($fh,$mode,$transfile);

  if ($output) {
    $fh = ($output eq "-" ? *STDERR : *STDOUT);
    $mode = ($output eq "-" ? 4 : 3);
  } else {
    $fh = *STDOUT;
    $mode = 3;
  }
 
  if ($output) {
    $transfile = ($output eq "-" ? "/dev/fd/1" : "$pkgdir/$output");
  } else {
    $output = "$ARGV[0].$arch.$rel.pkg";
    $transfile = "$pkgdir/$output";
  }
  print STDERR "output: $output\ntransfile: $transfile\n" if $debug;

  my @install_order = install($mode,0);	# download packages needed
  myexit("","",1) if (scalar(@install_order) == 0); # empty list, nothing to do
  print STDERR "install order: " . join(' ',@install_order) . "\n" if $debug;

  foreach (@install_order) {		# delete package directories
    my $status = system("/bin/rm -rf $pkgdir/$_") if (-d "$pkgdir/$_");
    die "Could not delete $pkgdir/$_: $!\n" if $status;
  }

  foreach (@install_order) {		# pkgtrans them one by one
    my $file = parse_catalog($_,3);
    print $fh "Transforming $_...\n";
    my $status = system("$gzip -c -f -d $pkgdir/$file | /bin/pkgtrans /dev/fd/0 $pkgdir all 2> /dev/null");
    die "Could not transform $file: $!\n" if $status;
  }

  # pkgtrans all of them into one package stream
  print $fh "Transforming packages into stream ($transfile)...\n";
  my $status = system("/bin/touch $transfile");
  die "Could not create stream file: $!\n" if $status;
  $status = system("/bin/pkgtrans -s $pkgdir $transfile all 2> /dev/null");
  die "Could not transform packages into stream: $!\n" if $status;

  foreach (@install_order) {		# delete package directories
    my $status = system("/bin/rm -rf $pkgdir/$_");
    die "Could not delete $pkgdir/$_: $!\n" if $status;
  }

  # print cmd needed to install
  print $fh "\nInstall commands in dependency safe order:\n\n";
  foreach (@install_order) {
    print $fh "pkgadd -d $output $_\n";
  }

  myexit("","",0);
}

# extract downloaded packages
#   pkglist - list of packages to extract (from install sub)
sub extract_pkg {
  my (@pkglist) = @_;

  foreach (@pkglist) {		# pkgtrans them one by one
    my $file = parse_catalog($_,3);
    print "Extracting $_ ($pkgdir)...\n";
    my $status = system("$gzip -c -f -d $pkgdir/$file | /bin/pkgtrans /dev/fd/0 $pkgdir all 2> /dev/null");
    die "Could not extract $file: $! (directory may already exist)\n" if $status;
  }
}

# show usage info
sub usage {
  print "pkgutil $pkgutilver, install Solaris packages the easy way.\n\n";
  print "Usage: pkgutil [option]... [package](-[version])...\n";
  print "\n  -i, --install\t\tInstall package";
  print "\n  -u, --upgrade\t\tUpgrade package";
  print "\n  -r, --remove\t\tRemove package (experimental)";
  print "\n  -d, --download\tDownload only";
  print "\n  -U, --catalog\t\tUpdate catalog";
  print "\n  -a, --available\tShow available packages";
  print "\n      --describe\tDescribe available packages";
  print "\n  -c, --compare\t\tCompare installed packages to current";
  print "\n  -C           \t\tSame as -c but only show different versions";
  print "\n  -e, --email=address\tSend e-mail with available updates";
  print "\n  -t, --temp=site\tTemporarily use this site as primary for download";
  print "\n  -x, --exclude=package\tPackage to exclude";
  print "\n  -W, --workdir=path\tPath to use for downloads";
  print "\n      --config=file\tUse this configuration file";
  print "\n  -y, --yes\t\tAnswer yes on all prompts";
  print "\n  -f, --force\t\tForce updates (sync with mirror)";
  print "\n  -n, --nomod\t\tNo modifications are made to the system";
  print "\n  -N, --nodeps\t\tNo dependencies";
  print "\n  -D, --debug\t\tDebug mode";
  print "\n      --trace\t\tSet trace mode (-v) for pkgadd/pkgrm";
  print "\n  -h, --help\t\tShow this help";
  print "\n  -v, --version\t\tShow version";
  print "\n  -V, --syscheck\tSystem check";
  print "\n  -L, --listfile\tList files in package";
  print "\n  -F, --findfile\tFind files in package";
  print "\n      --extract\t\tExtract package content (use with -d)";
  print "\n  -s, --stream\t\tBuild a package stream (use with -d)";
  print "\n  -o, --output=file\tFile name for package stream (use with -s)";
  print "\n  -T, --target=arch:rel\tSpecify architecture and OS release for download";
  print "\n      --single\t\tSingle package check (use with -c)";
  print "\n\nExample: pkgutil -i CSWwget\ (install wget and its dependencies)\n";
  print "\nWritten and maintained by Peter Bonivart.\n";
  myexit("","",0);
}

# comparison of two package versions as per
# http://pkgutil.wikidot.com/get-install-and-configure#toc7
# as per cmp or <=>, -1, 0, or 1 if p1 is less than, equal to or greater than p2
# Note that if neither has a REV code, -1 is *ALWAYS* returned.
#   p1rev, p2rev - versions to compare
sub verscmp {
  my($p1rev,$p2rev) = @_; # crev (new), irev (old), then 1 => upgrade
  my (@p1list,@p2list);
  my $p1tmp = "";
  my $p2tmp = "";
  my $update = 0;

  my $skip = 0;

  # 1st case: same strings => no upgrade
  $skip = 1 if ($p1rev eq $p2rev);

  # 2nd case: installed no REV, catalog REV => upgrade
  if (! $skip) {
    if ($p1rev !~ /REV=/ && $p2rev =~ /REV=/) {
      $update = -1;
      $skip = 1;
    } elsif ($p2rev !~ /REV=/ && $p1rev =~ /REV=/) {
      # Reverse case (installed REV, catalog no REV => "downgrade")
      $update = 1;
      $skip = 1;
    }
  }

  # 3rd case: installed REV, catalog REV => if newer, upgrade
  if (! $skip) {
    if ($p1rev =~ /REV=/ && $p2rev =~ /REV=/) {
      if ($p1rev =~ /rev=/) {
        ($p1tmp) = ($p1rev =~ /REV=(.+)_/);
      } else {
        ($p1tmp) = ($p1rev =~ /REV=(.+)$/);
      }
      @p1list = split(/\./,$p1tmp);

      if ($p2rev =~ /rev=/) {
        ($p2tmp) = ($p2rev =~ /REV=(.+)_/);
      } else {
        ($p2tmp) = ($p2rev =~ /REV=(.+)$/);
      }
      @p2list = split(/\./,$p2tmp);

      for (my $i = 0; $i < scalar(@p1list); $i++) {
        if (! $p2list[$i]) {
          $update = 1;
          last;
        }
        if ($p1list[$i] != $p2list[$i]) {
          if ($p1list[$i] > $p2list[$i]) {
            $update = 1;
          } else {
            $update = -1;
          }
          print STDERR "$i $p1list[$i] $p2list[$i] $update\n" if $debug;
          last;
        }
        print STDERR "$i $p1list[$i] $p2list[$i] $update\n" if $debug;
      }
      $update = -1 if (! $update && scalar(@p2list) > scalar(@p1list));

      $skip = 1;
    }
  }

  # 4th case: installed no REV, catalog no REV => upgrade
  if (! $skip) {
    $update = 1 if ($p1rev !~ /REV=/ && $p2rev !~ /REV=/);
  }

  return $update;
}

# main

init();
parse_cl();

myexit("","",0);

=head1 NAME

pkgutil - install Solaris packages the easy way

=head1 SYNOPSIS

pkgutil [option]... [package]...

=head1 DESCRIPTION

Pkgutil, written in Perl and licensed under GPL, is a tool to make installation of packages in Solaris easier.

It handles package dependencies so all required packages are installed before the desired package automatically.

A catalog is used to make this possible. The format is:

S<common_name version package_name file_name md5_hash pkg_size dependencies category>

Example:

S<bind 9.4.2,REV=2008.07.09_rev=p1 CSWbind bind-9.4.2,REV=2008.07.09_rev=p1-SunOS5.8-sparc-CSW.pkg.gz f68df57fcf54bfd37304b79d6f7eeacc 2954112 CSWcommon|CSWosslrt net>

In the example CSWbind has two dependencies separated by a pipe. Multiple categories can also be separated by pipe characters.

=head1 OPTIONS

=over 5

=item B<-i, --install>

Install package. Will install the specified packages with all their dependencies.  You may specify an explicit version (e.g. amarok-1.4.8,REV=2008.02.26) if desired, otherwise the latest version found is chosen.

=item B<-u, --upgrade>

Upgrade package. A special argument is "all" which will upgrade all installed packages if possible, no argument is the same as "all". If one or more packages are given as arguments only those will be upgraded.

=item B<-r, --remove>

Remove package. This will remove a package including all dependencies that are not in use by other packages.

=item B<-d, --download>

Download only. Same as install but stops after downloading the packages.

=item B<-U, --catalog>

Update catalog.

=item B<-a, --available>

Show available packages.

=item B<--describe>

Describe available packages.

=item B<-c, --compare>

Compare installed packages to current.

=item B<-C>

Compare installed packages to current, show only different versions.

=item B<-e, --email=address>

Send e-mail with available updates. E-mail address as argument. Don't use with other options.

=item B<-t, --temp=site>

Temporarily use this site for download. Must be the complete url where to find the catalog and associated packages. May be specified multiple times.

=item B<-s, --stream>

Build a package stream for a certain architecture and OS release. All dependencies will be included in the stream and the needed command to install them in the correct order will be displayed. Must be used with -d.

=item B<-T, --target=arch:rel>

Specify architecture and OS release when downloading, e.g. i386:5.9 or sparc:5.10. If not specified defaults to architecture and release of the host running pkgutil.

=item B<-o, --output=file>

File name for package stream. Used with -s. A special argument is "-" which sends the stream to standard output, see example below. The default name is the first package argument followed by architecture and OS release, for example "bind.i386.5.10.pkg".

=item B<-x, --exclude=package>

Package to exclude. This option can be specified multiple times.

=item B<-W, --workdir=path>

Path to use for downloads. This can be used to run pkgutil as non-root, e.g. called from a web server.

=item B<--config=file>

Use this configuration file instead of the default ones.

=item B<-y, --yes>

Answer yes on all prompts. Skips prompt when multiple packares are to be downloaded. Makes pkgrm/pkgadd operations more silent and without prompts. Only makes sense with -i and -u.

=item B<-f, --force>

Force updates regardless of version compare result, as long as local and mirror version is not the same an update is carried out. This can be used as a rollback from the testing mirror to current or from current to stable for example.

=item B<-n, --nomod>

No modifications are made to the system. Stops before downloading catalog/packages. Use it to simulate if catalog needs updating or which packages will be downloaded. Only makes sense with -i, -u and -U.

=item B<-N, --nodeps>

No dependencies, only what you specify on the command line will be used. Useful when using pkgutil as a download tool of specific packages or if you use the testing repo that might pull in unwanted packages.

=item B<-D, --debug>

Debug mode. Adds a lot of info about what's going on. Only use if you're having problems you think is a bug.

=item B<--trace>

Set trace mode (-v) for pkgadd/pkgrm.

=item B<-h, --help>

Show this help.

=item B<-v, --version>

Show pkgutil version.

=item B<-V, --syscheck>

System check. This shows info about binaries and more that pkgutil needs to support all features.

=item B<-L, --listfile>

List files in packages. Works on both installed packages as well as on (uncompressed) package files. You can even mix them on the command line.

=item B<-F, --findfile>

Find files in installed packages.

=item B<--extract>

Will fetch and extract package content. Must be used with -d.

=item B<--single>

Single package check. This is much faster than checking all installed packages, note that using something like "-c foo" still checks all packages, it just filters the output to only show lines containing foo. Must be used with -c.

=back

=head1 EXAMPLES

=head2 Example 1

C<# pkgutil -i CSWbind>

Will install CSWbind with all required dependencies.

=head2 Example 2

C<# pkgutil -e nobody@foo.bar>

Will run silently and send an e-mail (with mailx) to the given address if there's updated packages available. Run it from crontab once weekly.

=head2 Example 3

C<# pkgutil -y -o - -s bind | gzip E<gt> bind.pkg.gz>

Will send a package stream including all dependencies needed for CSWbind to standard output which is piped to gzip. With "-o -" the normal output is sent to standard error and "-y" is used to skip the confirmation prompt.

=head2 Example 4

C<# pkgutil -T i386:5.10 -s bind>

Will make a package stream including all dependencies needed for CSWbind. The package stream will contain packages for the i386 architecture and Solaris 10 regardless of host used to run pkgutil.

=head1 CONFIGURATION

Pkgutil uses a configuration file, pkgutil.conf, that contains a few important settings. No modifications are mandatory though since pkgutil will happily run with the defaults.

There's a configuration file in /opt/csw/etc/pkgutil.conf. The only thing you normally need to change there is the mirror location. If you have a pkgutil.conf file in /etc/opt/csw it will override the one in /opt/csw/etc on a setting-by-setting basis. If no pkgutil.conf is found in either of those two locations defaults are used.

The settings that can be used are:

C<catalog_update>

Number of days between automatic catalog updates. Special cases are -1 if you want to disable automatic updates and 0 if you always want to update the catalog. Default is 14.

C<exclude_pattern>

Space separated list of simple patterns that will exclude matching packages when updating or installing. If you, e.g., never want cups related packages updated accidentally you can add the string cups here, this will exclude all package names that contain that string. Default is blank.

C<maxpkglist>

During dependency calculation the recursive algorithm needs to be protected against cyclic dependencies in the catalog (packages that list each other as dependencies) or pkgutil will not stop until memory is exhausted. This sets the maximum number of recursions before pkgutil stops.

C<mirror>

This is the mirror that is used for downloading the catalog and packages. Try setting it to your nearest mirror to improve download speed. This option may be specified multiple times.

It also supports (in an experimental way) the file:// protocol for local/NFS mirrors. Example: C<mirror=file:///absolute/path/to/files>

C<noncsw>

Enable (default is disable) support for non-CSW prefixed packages.

Pkgutil also uses a file to configure pkgadd when the yes (-y) option is used. This file is located in /var/opt/csw/pkgutil and is called admin. It's by default set up to fully automate installations but if you change something in this file it will be preserved during upgrades of pkgutil. Read more about the admin file with "man -s4 admin".

C<pkgaddopts>

Send options to pkgadd, one example is -G that will only install the packages in the global zone for Solaris 10.

C<pkgliststyle>

Style of package list when installing/upgrading packages. 0 is the one used since the first version of pkgutil, it's space efficient but less readable. 1 is the one introduced in v1.7, it's one package per line which is easier to read.

C<use_gpg>
C<use_md5>

These two can enable (default is disabled for both) checking the catalogs integrity (GPG) and that each downloaded file is unchanged from the published one (MD5). To use GPG you need CSWgnupg installed. MD5 is supported by default in Solaris 10 and on Solaris 8 and 9 if you have CSWperl installed and have /opt/csw/bin first in your path. You can also install CSWtextutils to get MD5 support.
 
C<wgetopts>

Send options to wget, for example to show more or less information during downloads.

C<stop_on_hook_soft_error>

This option determines whether or not execution will be halted if a hook returns 2 as its exit code.  Execution is always stopped if a hook returns 1.  Set this to true to enable it.

=head1 PKGASK RESPONSE FILES

Pkgutil supports pkgask response files and will use them if you provide them. Create a pkgask directory in your work directory (normally /var/opt/csw/pkgutil) and put your response files there.

=head1 SEE ALSO

http://pkgutil.wikidot.com

http://sourceforge.net/projects/pkgutil

=head1 TODO

Some functionality and lots of error handling.

=head1 AUTHOR

Peter Bonivart <bonivart@opencsw.org>

=head1 CREDITS

Maciej Blizinski

Dennis Clarke

Ihsan Dogan

David Everly

Don Jackson

Sebastian Kayser

Trygve Laugstol

James Lee

Dagobert Michelsen

Yann Rouillard

Ben Walton

Derek Whayman

For more details, see the readme file.

=head1 COPYRIGHT AND DISCLAIMER

Copyright (C) 2008-2009 Peter Bonivart. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

=cut

